# 병합정렬, 퀵정렬

## 김민수

### 병합정렬

일반적인 방법으로 구현했을 때, 안정 정렬에 속하며, 분할 정복 알고리즘을 이용한 정렬 방법이다.

<img src="https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png" style width="700"/>

#### 과정

- 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.
- 정렬되지 않은 리스트를 절반으로 잘라 2개의 비슷한 크기를 갖는 리스트로 나눈다. (분할)
- 각 부분 리스트를 재귀적으로 병합정렬을 이용해 정렬한다. (정복)
- 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. (결합)



<img src="http://www-scf.usc.edu/~zhan468/public/Notes/resources/CDDA3F11C6EFBC01577F5C29A9066772.gif" style width="600"/>

#### 장단점

- 장점
  - 안정적인 정렬방법으로 데이터의 분포에 관계없이 항상 O(n log n)을 만족한다.
  - 레코드를 linked list로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 작아진다. 즉, 제자리 정렬로 구현할 수 있다.
- 단점
  - 레코드를 배열로 구성하면 임시 배열이 필요하다. 즉 제자리 정렬이 아니다.
  - 레코드들의 크기가 큰 경우, 이동횟수가 많아 시간 낭비가 발생한다.

### 퀵정렬

퀵정렬은 불안정 정렬이며, 분할 정복 알고리즘을 이용한 정렬 방법이다. 

<img src="http://www-scf.usc.edu/~zhan468/public/Notes/resources/C411339B79F92499DCB7B5F304C826F4.gif" style width="600"/>

#### 과정

1. 피봇을 선택한다. (첫 요소, 중간 요소, 끝 요소, 랜덤으로 선택할 수 있다.)

2. 오른쪽(j)에서 왼쪽으로 가면서 피봇보다 작은 수를 찾는다.

3. 왼쪽(i)에서 오른쪽으로 가면서 피봇보다 큰 수를 찾는다.

4. i, j의 요소를 교환한다.

5. 위 2, 3, 4 과정을 반복한다.
6. 2, 3번을 더 이상 진행할 수 없다면, 피봇과 교환한다.
7. 그 결과는 피벗을 중심으로 왼쪽은 피봇보다 작은 수, 오른쪽은 피봇보다 큰 수들이 존재한다.

#### 장단점

- 장점
  - 재귀 방식을 이용하여 코드가 간결하다.
  - 평균 시간 복잡도가 n log n이라 정렬이 빠르다.
- 단점
  - 피봇 선택에 따라 최악의 경우 n^2의 시간복잡도를 가질 수 있다.

| 이름     | Best    | Avg     | Worst   | 공간        | 안정 정렬? |
| -------- | ------- | ------- | ------- | ----------- | ---------- |
| 병합정렬 | n log n | n log n | n log n | n           | o          |
| 퀵정렬   | n log n | n log n | n^2     | log n, O(n) | x          |

<br>

## 이유진
### 병합 정렬 (Merge sort)
> 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법

![](https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png)
- **안정 정렬**에 속함
- **분할 정복** 알고리즘
  - 분할 (Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
  - 정복 (Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 (1초과인 경우) 다시 분할 정복 방법을 적용한다.
  - 결합 (Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.
- 추가적인 리스트가 필요하다. (임시배열) -> **제자리 정렬이 아니다.**
- 실제로 정렬이 이루어지는 시점은 2개의 부분 배열을 합병(merge)하는 단계이다.
- 데이터의 분포에 영향을 덜 받는다. 데이터에 상관없이 시간복잡도는 `O(NlogN)`으로 동일하다.
  - `합병단계(=순환 호출의 깊이=N)` * `각 단계의 비교 연산(=logN)` = NlogN
- **연결 리스트(LinkedList)로 구성한다면**, 링크 인덱스만 변경하므로 데이터의 이동은 매우 작아진다. 제자리정렬로 구현할 수도 있다.
  - 크기가 큰 레코드의 경우 연결 리스트를 사용한다면, 다른 방법들보다 효율적인 정렬 방법이다.

### 퀵 정렬 (Quick sort)
> pivot을 기준으로 두 개의 비균등한 리스트로 분할하여 정렬한 다음, 두 부분 리스트를 합하는 과정을 반복하여 정렬된 하나의 리스트가 되게 하는 방법

![](https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort-concepts.png)

- **불안정 정렬**에 속함
- **분할 정복** 알고리즘, 평균적으로 **매우 빠른 속도를 자랑**한다!
  - 병합 정렬과 달리, 배열을 비균등하게 분할함
  1. 리스트 안에서 한 요소를 선택 (pivot)
  2. pivot을 기준으로, pivot보다 작은 요소들은 모두 pivot의 왼쪽으로 옮기고, 큰 요소들은 모두 pivot의 오른쪽으로 옮긴다.
  3. pivot을 제외한 좌,우 리스트에 대해 1번부터 반복한다.
  4. 부분 리스트들이 더 이상 분할이 불가능 할 때까지 반복한다.
- 속도가 빠르다. 시간복잡도 `O(NlogN)` (대체로 실제로는 더 빠르다. / 최악의 경우 `O(N^2)`
  - `합병단계(=순환 호출의 깊이=N)` * `각 단계의 비교 연산(=logN)` = NlogN
  - 퀵 정렬은 불필요한 데이터 이동을 줄이고, 한 번 결정된 pivot은 추후 연산에서 제외되므로 빠르다!
- 추가 메모리 공간을 필요로 하지 않는다.
- 정렬된 리스트에 대해서는 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
  - 리스트가 계속 불균형하게 나누어지는 경우 비효율적이다.
  - 따라서, pivot을 선택할 때 **리스트를 균등하게 분할할 수 있는 데이터를 선택**하는 것이 유리하다. (ex. 중간 값)

#### 퀵 정렬 알고리즘
![](https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort2.png)
