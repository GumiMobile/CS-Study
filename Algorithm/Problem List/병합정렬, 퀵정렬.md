# 병합정렬, 퀵정렬

## 김민수

### 병합정렬

일반적인 방법으로 구현했을 때, 안정 정렬에 속하며, 분할 정복 알고리즘을 이용한 정렬 방법이다.

<img src="https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png" style width="700"/>

#### 과정

- 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.
- 정렬되지 않은 리스트를 절반으로 잘라 2개의 비슷한 크기를 갖는 리스트로 나눈다. (분할)
- 각 부분 리스트를 재귀적으로 병합정렬을 이용해 정렬한다. (정복)
- 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. (결합)



<img src="http://www-scf.usc.edu/~zhan468/public/Notes/resources/CDDA3F11C6EFBC01577F5C29A9066772.gif" style width="600"/>

#### 장단점

- 장점
  - 안정적인 정렬방법으로 데이터의 분포에 관계없이 항상 O(n log n)을 만족한다.
  - 레코드를 linked list로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 작아진다. 즉, 제자리 정렬로 구현할 수 있다.
- 단점
  - 레코드를 배열로 구성하면 임시 배열이 필요하다. 즉 제자리 정렬이 아니다.
  - 레코드들의 크기가 큰 경우, 이동횟수가 많아 시간 낭비가 발생한다.

### 퀵정렬

퀵정렬은 불안정 정렬이며, 분할 정복 알고리즘을 이용한 정렬 방법이다. 

<img src="http://www-scf.usc.edu/~zhan468/public/Notes/resources/C411339B79F92499DCB7B5F304C826F4.gif" style width="600"/>

#### 과정

1. 피봇을 선택한다. (첫 요소, 중간 요소, 끝 요소, 랜덤으로 선택할 수 있다.)

2. 오른쪽(j)에서 왼쪽으로 가면서 피봇보다 작은 수를 찾는다.

3. 왼쪽(i)에서 오른쪽으로 가면서 피봇보다 큰 수를 찾는다.

4. i, j의 요소를 교환한다.

5. 위 2, 3, 4 과정을 반복한다.
6. 2, 3번을 더 이상 진행할 수 없다면, 피봇과 교환한다.
7. 그 결과는 피벗을 중심으로 왼쪽은 피봇보다 작은 수, 오른쪽은 피봇보다 큰 수들이 존재한다.

#### 장단점

- 장점
  - 재귀 방식을 이용하여 코드가 간결하다.
  - 평균 시간 복잡도가 n log n이라 정렬이 빠르다.
- 단점
  - 피봇 선택에 따라 최악의 경우 n^2의 시간복잡도를 가질 수 있다.

| 이름     | Best    | Avg     | Worst   | 공간        | 안정 정렬? |
| -------- | ------- | ------- | ------- | ----------- | ---------- |
| 병합정렬 | n log n | n log n | n log n | n           | o          |
| 퀵정렬   | n log n | n log n | n^2     | log n, O(n) | x          |

<br>

## 이유진
### 병합 정렬 (Merge sort)
> 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법

<img src="https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png" width="500">
- **안정 정렬**에 속함
- **분할 정복** 알고리즘
  - 분할 (Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
  - 정복 (Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 (1초과인 경우) 다시 분할 정복 방법을 적용한다.
  - 결합 (Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.
- 추가적인 리스트가 필요하다. (임시배열) -> **제자리 정렬이 아니다.**
- 실제로 정렬이 이루어지는 시점은 2개의 부분 배열을 합병(merge)하는 단계이다.
- 데이터의 분포에 영향을 덜 받는다. 데이터에 상관없이 시간복잡도는 `O(NlogN)`으로 동일하다.
  - `합병단계(=순환 호출의 깊이=N)` * `각 단계의 비교 연산(=logN)` = NlogN
- **연결 리스트(LinkedList)로 구성한다면**, 링크 인덱스만 변경하므로 데이터의 이동은 매우 작아진다. 제자리정렬로 구현할 수도 있다.
  - 크기가 큰 레코드의 경우 연결 리스트를 사용한다면, 다른 방법들보다 효율적인 정렬 방법이다.

### 퀵 정렬 (Quick sort)
> pivot을 기준으로 두 개의 비균등한 리스트로 분할하여 정렬한 다음, 두 부분 리스트를 합하는 과정을 반복하여 정렬된 하나의 리스트가 되게 하는 방법

<img src="https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort-concepts.png" width="500">

- **불안정 정렬**에 속함
- **분할 정복** 알고리즘, 평균적으로 **매우 빠른 속도를 자랑**한다!
  - 병합 정렬과 달리, 배열을 비균등하게 분할함
  1. 리스트 안에서 한 요소를 선택 (pivot)
  2. pivot을 기준으로, pivot보다 작은 요소들은 모두 pivot의 왼쪽으로 옮기고, 큰 요소들은 모두 pivot의 오른쪽으로 옮긴다.
  3. pivot을 제외한 좌,우 리스트에 대해 1번부터 반복한다.
  4. 부분 리스트들이 더 이상 분할이 불가능 할 때까지 반복한다.
- 속도가 빠르다. 시간복잡도 `O(NlogN)` (대체로 실제로는 더 빠르다. / 최악의 경우 `O(N^2)`
  - `합병단계(=순환 호출의 깊이=N)` * `각 단계의 비교 연산(=logN)` = NlogN
  - 퀵 정렬은 불필요한 데이터 이동을 줄이고, 한 번 결정된 pivot은 추후 연산에서 제외되므로 빠르다!
- 추가 메모리 공간을 필요로 하지 않는다.
- 정렬된 리스트에 대해서는 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
  - 리스트가 계속 불균형하게 나누어지는 경우 비효율적이다.
  - 따라서, pivot을 선택할 때 **리스트를 균등하게 분할할 수 있는 데이터를 선택**하는 것이 유리하다. (ex. 중간 값)

#### 퀵 정렬 알고리즘
<img src="https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort2.png" width="600">


## 이수형

### 병합 정렬

리스트를 잘게 쪼갠뒤 둘씩 크기를 비교해 정렬하고 재귀적으로 합쳐나가면서 정렬을 완성하는 방법

1. 리스트를 원소가 1개 남을때까지 계속 분할
2. 분할의 역방향으로 다시 합쳐나가면서 작은 부분부터 정렬해나감

- 대표적 분할 정복 알고리즘

- 안정적인 정렬방법, 항상 O(NlogN)을 보장 (분할에 O(logN), 병합에 O(N))

- 배열로 구성시 저장해둘 공간이 필요해 메모리 소모가 크다

- 연결리트스로 구성시 제자리 정렬이 가능하다 (인덱스만 변경하여 구현하므로)

- 크기가 아주 큰 정렬시 연결리스트로 구현하면 효율적이다

### 퀵정렬

피봇을 중심으로 왼쪽과 오른쪽 집합으로 분할해 나가면서 정렬을 완성하는 방법

1. 배열의 왼쪽부터 오른쪽까지 가면서 피봇보다 큰 수를 찾는다
2. 배열의 오른쪽부터 왼쪽까지 가면서 피봇보다 작은수를 찾는다
3. 1,2의 결과를 swap 한다 
> 2의 결과가 1보다 왼쪽에 있으면 피봇과 2의 결과를 swap한다

- 분할 정복 알고리즘

- 불안정 정렬방법, Θ(NlogN)을 보장하나 정렬된경우 O(N^2)의 시작복잡도를 가짐

- 불필요한 데이터의 이동을 줄이고 한 번 결정된 피봇은 추후 연산에서 제외되므로 빠르다

- 추가 메모리가 필요없다

- 피봇에 따라 성능차이가 나며 피봇이 리스트를 균형적이게 나누지 못하는경우 성능이 떨어진다 그러므로 피봇을 정하는 방법이 중요하다

## 우지현

### 병합 정렬 (Merge Sort)

![병합 정렬](http://www-scf.usc.edu/~zhan468/public/Notes/resources/CDDA3F11C6EFBC01577F5C29A9066772.gif)

- 합병 정렬이라고도 부르며, **분할 정복(divide and conquer) 방법**을 통해 구현한다.

  > 분할 정복 (divide and conquer)
  >
  > 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략

- 빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다.

- `안정 정렬 (Stable Sort)`

- 요소를 분할한 후, 다시 합병시키면서 정렬해나가는 방식으로, 분할하는 방식은 퀵 정렬과 유사하다.

- 퀵 정렬과의 차이점

  - 퀵 정렬 : 우선 피벗을 통해 정렬 (partition) -> 영역을 분할한다 (quickSort)
  - 병합 정렬 : 영역을 분할할 수 있을 만큼 나눈다 (mergeSort) -> 정렬 (merge)

- 병합 정렬은 합병의 대상이 되는 두 영역이 각 영역에 대해서 정렬되어 있기 때문에 단순히 두 배열을 순차적으로 비교하면서 정렬할 수 있다.

- 합병 정렬은 순차적인 비교로 정렬을 진행하므로, LinkedList의 정렬이 필요할 때 사용하면 효율적이다.

  - LinkedList를 퀵 정렬로 정렬하면?

    > 퀵 정렬은 순차 접근(sequential access)이 아닌 임의 접근(random aceess)이기 때문에 성능이 좋지 않다.

  - LinkedList는 삽입, 삭제 연산에서 유용하지만 접근 연산에서는 비효율적이기 때문에 임의로 접근하는 퀵 정렬을 활용하면 오버헤드 발생이 증가한다.

    > 배열은 인덱스를 이용해서 접근이 가능하지만 LinkedList는 head부터 탐색해야 한다.
    >
    > 배열 `O(1)` vs LinkedList `O(n)` 

- 시간 복잡도

  |   평균   |   최선   |   최악   |
  | :------: | :------: | :------: |
  | Θ(nlogn) | Ω(nlogn) | O(nlogn) |

### 퀵 정렬 (Quick Sort)

![퀵 정렬](http://www-scf.usc.edu/~zhan468/public/Notes/resources/C411339B79F92499DCB7B5F304C826F4.gif)

- 퀵 정렬은 **분할 정복 방법**을 통해 주어진 배열을 정렬한다.
- 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.
- 병합 정렬(Merge Sort)와 달리 퀵 정렬(Quick Sort)은 배열을 비균등하게 분할한다.
- Java에서 Arrays.sort() 내부적으로도 Dual Pivot Quick Sort로 구현되어 있을 정도로 효율적인 알고리즘이다.
- 장점
  - 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
  - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. 
- 단점
  - `불안정 정렬 (Unstable Sort)`
  - 정렬된 배열에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다. 

#### 퀵 정렬 과정 (오름차순, Ascending)

1. 배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 `피벗(pivot)`이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 `분할(divide)`이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
3. 분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.

재귀 호출이 한 번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

#### 퀵 정렬의 시간 복잡도와 공간 복잡도

시간 복잡도

|   평균    |   최선    |  최악  |
| :-------: | :-------: | :----: |
| O(nlog₂n) | O(nlog₂n) | O(n^2) |

- 최선 `O(nlog₂n)`

  - 비교 횟수 `log₂n`

    ![퀵 정렬 최선 비교 횟수](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-002.png)

    - 레코드의 개수 n이 2의 거듭제곱이라고 가정했을 때 (n = 2^k), n = 2^3의 경우 2^3 -> 2^2 -> 2^1 -> 2^0순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다.
    - 일반화하면 n = 2^k의 경우 `k(k = log₂n)`임을 알 수 있다.

  - 각 순환 호출 단계의 비교 연산 `n`

    - 각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.

  - 따라서 최선의 시간 복잡도는 `순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = nlog₂n`가 된다.

  - 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.

- 최악 `O(n^2)`

  - 정렬하고자 하는 배열이 오름차순 또는 내림차순으로 정렬되어 있는 경우

  - 비교 횟수 `n`

    ![퀵 정렬 최악 비교 횟수](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-003.png)

    - 레코드의 개수 n이 2의 거듭제곱이라 가정했을 때 (n = 2^k), 순환 호출의 깊이는 `n`임을 알 수 있다.

  - 각 순환 호출 단계의 비교 연산 `n`

    - 각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 평균 n번 정도의 비교가 이루어진다.

  - 따라서 최악의 시간 복잡도는 `순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = n^2`이다.

  - 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.

공간 복잡도

- 주어진 배열 안에서 교환(swap)을 통해 정렬이 수행되므로 O(n)

## 김현수

### 병합정렬(Merge Sort)
- 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
- 분할 정복 알고리즘의 하나이다.
	- 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
	- 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
	- 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
- 장점
	- 안정적인 정렬 방법
		- 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog₂n)로 동일)
	- 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
		- 제자리 정렬(in-place sorting)로 구현할 수 있다.
	- 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.
- 단점
	- 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
		- 제자리 정렬(in-place sorting)이 아니다.
	- 레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

### 퀵 정렬(Quick Sort)
- 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 부분리스트로 나누어 하나는 피벗보다 작은 값들의 부분리스트, 다른 하나는 피벗보다 큰 값들의 부분리스트로 정렬한 다음, 각 부분리스트에 대해 다시 위 처럼 재귀적으로 수행하여 정렬하는 방법이다.
- 병합정렬은 하나의 리스트를 '절반'으로 나누어 분할 정복을 하지만, 퀵 정렬은 피벗(pivot)의 값에 따라 피벗보다 작은 값을 갖는 부분리스트와 피벗보다 큰 값을 갖는 부분리스트의 크기가 다를 수 있기 때문에 하나의 리스트에 대해 비균등하게 나뉜다.
- 피벗을 선택하는 과정은 여러 방법이 있는데, 대표적으로 현재 부분배열의 가장 왼쪽 원소가 피벗이 되는 방법, 중간 원소가 피벗이 되는 방법, 마지막 원소가 피벗이 되는 방법이다.
- 과정
	1. 피벗을 하나 선택한다.
	2. 피벗을 기준으로 양쪽에서 피벗보다 큰 값, 혹은 작은 값을 찾는다. 왼쪽에서부터는 피벗보다 큰 값을 찾고, 오른쪽에서부터는 피벗보다 작은 값을 찾는다.
	3. 양 방향에서 찾은 두 원소를 교환한다.
	4. 왼쪽에서 탐색하는 위치와 오른쪽에서 탐색하는 위치가 엇갈리지 않을 때 까지 2번으로 돌아가 위 과정을 반복한다.
	5. 엇갈린 기점을 기준으로 두 개의 부분리스트로 나누어 1번으로 돌아가 해당 부분리스트의 길이가 1이 아닐 때 까지 1번 과정을 반복한다. (Divide : 분할)
	6. 인접한 부분리스트끼리 합친다. (Conqure : 정복)
- 장점
	- 평균적으로 시간 복잡도는 O(nlogn)이며, 다른 O(nlogn) 알고리즘에 비해 대체적으로 속도가 매우 빠르다. 
		- 유사하게 O(nlogn) 정렬 알고리즘 중 분할정복 방식인 병합정렬에 비해 2~3배정도 빠르다.
	- 추가 메모리 공간을 필요로 하지 않는다.
- 단점
	- 분할한 결과가 한쪽으로 몰리는 최악의 경우에는 시간복잡도가 O(n^2)이다.
	- 불안정 정렬이다.


## 윤기재

### 합병 정렬(merge sort)
- 합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다. 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다.



### 분할 정복(divide and conquer) 방법
1. 리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우
2. 분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트	로 나눈다.
3. 정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
4. 결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정	렬 결과가 임시배열에 저장된다.
5. 복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.

### 퀵 정렬
- 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.
- 퀵 정렬은 n개의 데이터를 정렬할 때, 최악의 경우에는 O(n2)번의 비교를 수행하고, 평균적으로 O(n log n)번의 비교를 수행한다.

### 실행순서
1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗이라고 한다.
2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 
3. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
4. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.

피벗은 p, 리스트 왼쪽 끝과 오른쪽 끝에서 시작한 인덱스들을 i,j라고 하자.
|5|3|7|6|2|1|4|
|-|-|-|-|-|-|-|
|-|-|-|-|-|-|p|

리스트 왼쪽에 있는 i 위치의 값이 피벗 값보다 크고, 오른쪽에 있는 j 위치의 값은 피벗 값보다 작으므로 둘을 교환한다.

|5|3|7|6|2|1|4|
|-|-|-|-|-|-|-|
|i|-|-|-|-|j|p|

|1|3|7|6|2|5|4|
|-|-|-|-|-|-|-|
|i|-|-|-|-|j|p|

j 위치의 값이 피벗 값보다 작지만, i 위치의 값도 피벗값보다 작으므로 교환하지 않는다.

|1|3|7|6|2|5|4|
|-|-|-|-|-|-|-|
|-|i|-|-|j|-|p|

i위치를 피벗 값보다 큰 값이 나올 때까지 진행해 j 위치의 값과 교환한다.

|1|3|7|6|2|5|4|
|-|-|-|-|-|-|-|
|-|-|i|-|j|-|p|

|1|3|2|6|7|5|4|
|-|-|-|-|-|-|-|
|-|-|i|-|j|-|p|

i위치가 j 위치보다 커지면, i 위치의 값과 피벗 값을 교환한다.

|1|3|2|6|7|5|4|
|-|-|-|-|-|-|-|
|-|-|-|ij|-|-|p|

|1|3|2|4|7|5|6|
|-|-|-|-|-|-|-|
|-|-|-|p|-|-|-|

피벗 값 좌우의 리스트에 대해 각각 퀵 정렬을 재귀적으로 수행한다. <br/>

| 1 - 3 - 2    |   7 - 5 - 6|
| 1 - 2 - 3    |   5 - 6 - 7 | <br/>
완성된 리스트는 다음과 같다. <br/>
1 - 2 - 3 - 4 - 5 - 6 – 7
