# 병합정렬, 퀵정렬

## 김민수

### 병합정렬

일반적인 방법으로 구현했을 때, 안정 정렬에 속하며, 분할 정복 알고리즘을 이용한 정렬 방법이다.

<img src="https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png" style width="700"/>

#### 과정

- 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.
- 정렬되지 않은 리스트를 절반으로 잘라 2개의 비슷한 크기를 갖는 리스트로 나눈다. (분할)
- 각 부분 리스트를 재귀적으로 병합정렬을 이용해 정렬한다. (정복)
- 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. (결합)



<img src="http://www-scf.usc.edu/~zhan468/public/Notes/resources/CDDA3F11C6EFBC01577F5C29A9066772.gif" style width="600"/>

#### 장단점

- 장점
  - 안정적인 정렬방법으로 데이터의 분포에 관계없이 항상 O(n log n)을 만족한다.
  - 레코드를 linked list로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 작아진다. 즉, 제자리 정렬로 구현할 수 있다.
- 단점
  - 레코드를 배열로 구성하면 임시 배열이 필요하다. 즉 제자리 정렬이 아니다.
  - 레코드들의 크기가 큰 경우, 이동횟수가 많아 시간 낭비가 발생한다.

### 퀵정렬

퀵정렬은 불안정 정렬이며, 분할 정복 알고리즘을 이용한 정렬 방법이다. 

<img src="http://www-scf.usc.edu/~zhan468/public/Notes/resources/C411339B79F92499DCB7B5F304C826F4.gif" style width="600"/>

#### 과정

1. 피봇을 선택한다. (첫 요소, 중간 요소, 끝 요소, 랜덤으로 선택할 수 있다.)

2. 오른쪽(j)에서 왼쪽으로 가면서 피봇보다 작은 수를 찾는다.

3. 왼쪽(i)에서 오른쪽으로 가면서 피봇보다 큰 수를 찾는다.

4. i, j의 요소를 교환한다.

5. 위 2, 3, 4 과정을 반복한다.
6. 2, 3번을 더 이상 진행할 수 없다면, 피봇과 교환한다.
7. 그 결과는 피벗을 중심으로 왼쪽은 피봇보다 작은 수, 오른쪽은 피봇보다 큰 수들이 존재한다.

#### 장단점

- 장점
  - 재귀 방식을 이용하여 코드가 간결하다.
  - 평균 시간 복잡도가 n log n이라 정렬이 빠르다.
- 단점
  - 피봇 선택에 따라 최악의 경우 n^2의 시간복잡도를 가질 수 있다.

| 이름     | Best    | Avg     | Worst   | 공간        | 안정 정렬? |
| -------- | ------- | ------- | ------- | ----------- | ---------- |
| 병합정렬 | n log n | n log n | n log n | n           | o          |
| 퀵정렬   | n log n | n log n | n^2     | log n, O(n) | x          |

