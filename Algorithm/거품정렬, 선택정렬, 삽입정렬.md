## 거품정렬, 선택정렬, 삽입정렬

### 이수형

### 1. Bubble Sort

서로 인접한 두 원소를 검사하여 정렬하는 알고리즘

- 버블 정렬은 1,2번째를 비교하고 2,3 번째를 비교하고 이런 식으로 N-1번째와 N번째를 비교하여 교환하면서 자료를 정렬한다.
- 이렇게 한번 끝나고 나면 가장 큰 데이터가 맨뒤 N번째에 있게 되어서 2회차는 N-1번째까지만 정렬하고 3회차는 N-2번째까지.. 이런식으로 정렬해간다

```
55 07 78 12 42  초기값
[1회전]
07 55 78 12 42  
07 55 78 12 42
07 55 12 78 42
07 55 12 42 78
[2회전]
07 55 12 42 78
07 12 55 42 78
07 12 42 55 78 
[3회전]
07 12 42 55 78  
07 12 42 55 78 
[4회전] 
07 12 42 55 78  정렬 끝
```

### 2. Selection Sort

- 선택 정렬은 입력 배열 이외에 다른 추가 메모리를 요구하지 않는 방법
- 해당 순서에 어떤 원소를 넣을지 선택하는 알고리즘
    - 최솟값을 찾아 맨 앞에 값과 교체한다
    - 맨앞을 제외한 나머지 배열중 최솟값을 새로운 맨앞의 값과 교체한다
    - 마지막까지 반복한다

```
9 1 6 8 4 3 2 0 -> 초기배열 최솟값 0
[1회전]
[0] 1 6 8 4 3 2 9 -> 최솟값 1
[2회전]
[0 1] 6 8 4 3 2 9 -> 최솟값 2
[3회전]
[0 1 2] 8 4 3 6 9 -> 최솟값 3
[4회전]
[0 1 2 3] 4 8 6 9 -> 최솟값 4
[5회전]
[0 1 2 3 4] 8 6 9 -> 최솟값 6
[6회전]
[0 1 2 3 4 6] 8 9 -> 최솟값 8
[최종]
[0 1 2 3 4 6 8 9] 
```

### 3. Insertion Sort

배열의 모든 요소를 앞에서 부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입하여 정렬

- 삽입정렬은 두번째 원소부터 시작하고 그 앞의 원소들과 비교하여 삽입할 위치를 정하고 그 위치사이에 삽입

```
31	25	12	22	11			처음 상태.
31	[25]	12	22	11		 	두 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<25>	31	[12]	22	11		 	세 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<12>	25	31	[22]	11		 	네 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
12	<22>	25	31	[11]		 	마지막 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<11>	12	22	25	31		 	종료.
```

### Bubble, Selection, Insertion Sort 비교

| SORT   | BEST             | AVG | WORST |
|--------|------------------|-----|-------|
| Bubble | O(N<sup>2</sup>) | O(N<sup>2</sup>) | O(N<sup>2</sup>) |
| Selection | O(N<sup>2</sup>) | O(N<sup>2</sup>) | O(N<sup>2</sup>) |
| Insertion | O(N) | O(N<sup>2</sup>) | O(N<sup>2</sup>) |

3개의 정렬 방식 전부 구현이 단순하지만 O(N^2)인 정렬이므로 비효율적인 방법이라고 할 수있다

<br><br>

### 김현수

### 거품정렬 (Bubble Sort)
- 두 개의 인접한 원소를 비교하여 정렬하는 방식
- 정렬 과정(오름차순)
	1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교한다.
	2. 현재 원소가 다음 원소보다 크면 원소를 교환한다.
	3. 다음 원소로 이동하여 해당 원소와 그 다음원소를 비교한다.
- 총 라운드는 (배열 크기-1) 번 진행되고, 각 라운드별 비교 횟수는 (배열 크기-라운드 횟수)이다.
- 장점: 추가적인 메모리 소비가 적고, 구현이 매우 쉬우며, 안정 정렬이 가능하다.
- 단점: 다른 정렬 알고리즘에 비해 교환 과정이 많아 많은 시간을 소비한다.
- 시간복잡도는 O(N^2)

### 선택정렬 (Selection Sort)
- 현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘
- 정렬 과정(오름차순)
	1. 주어진 리스트에서 최솟값을 찾는다.
	2. 최솟값을 맨 앞 자리의 값과 교환한다.
	3. 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.
- 장점: 추가적인 메모리 소비가 적다.
- 단점: 안정 정렬이 아니다.
- 시간복잡도는 O(N^2)

### 삽입정렬 (Insertion Sort)
- 현재 비교하고자 하는 target(타겟)과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법
- 앞에서부터 해당 원소가 위치 할 곳을 탐색하고 해당 위치에 삽입한다. 즉, 타겟 이전 원소가 타겟 숫자보다 크기 직전까지 모든 수를 뒤로 한 칸씩 밀어낸다.
- 정렬 과정(오름차순)
	1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. (첫 번째 타겟은 두 번째 원소부터 시작한다.)
	2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
	3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다. 
- 장점: 추가적인 메모리 소비가 적으며 안정 정렬이 가능하고, 최선의 경우 O(N)의 시간복잡도를 갖는다.
- 단점: 데이터의 상태에 따라서 성능 편차가 매우 크다. (최악의 경우 O(N2)의 시간 복잡도를 갖는다.)
- 평균적인 시간 복잡도는 O(N^2)
