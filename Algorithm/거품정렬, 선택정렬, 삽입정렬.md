# 거품정렬, 선택정렬, 삽입정렬

## 이수형

### 1. Bubble Sort

서로 인접한 두 원소를 검사하여 정렬하는 알고리즘

- 버블 정렬은 1,2번째를 비교하고 2,3 번째를 비교하고 이런 식으로 N-1번째와 N번째를 비교하여 교환하면서 자료를 정렬한다.
- 이렇게 한번 끝나고 나면 가장 큰 데이터가 맨뒤 N번째에 있게 되어서 2회차는 N-1번째까지만 정렬하고 3회차는 N-2번째까지.. 이런식으로 정렬해간다

```
55 07 78 12 42  초기값
[1회전]
07 55 78 12 42  
07 55 78 12 42
07 55 12 78 42
07 55 12 42 78
[2회전]
07 55 12 42 78
07 12 55 42 78
07 12 42 55 78 
[3회전]
07 12 42 55 78  
07 12 42 55 78 
[4회전] 
07 12 42 55 78  정렬 끝
```

### 2. Selection Sort

- 선택 정렬은 입력 배열 이외에 다른 추가 메모리를 요구하지 않는 방법
- 해당 순서에 어떤 원소를 넣을지 선택하는 알고리즘
    - 최솟값을 찾아 맨 앞에 값과 교체한다
    - 맨앞을 제외한 나머지 배열중 최솟값을 새로운 맨앞의 값과 교체한다
    - 마지막까지 반복한다

```
9 1 6 8 4 3 2 0 -> 초기배열 최솟값 0
[1회전]
[0] 1 6 8 4 3 2 9 -> 최솟값 1
[2회전]
[0 1] 6 8 4 3 2 9 -> 최솟값 2
[3회전]
[0 1 2] 8 4 3 6 9 -> 최솟값 3
[4회전]
[0 1 2 3] 4 8 6 9 -> 최솟값 4
[5회전]
[0 1 2 3 4] 8 6 9 -> 최솟값 6
[6회전]
[0 1 2 3 4 6] 8 9 -> 최솟값 8
[최종]
[0 1 2 3 4 6 8 9] 
```

### 3. Insertion Sort

배열의 모든 요소를 앞에서 부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입하여 정렬

- 삽입정렬은 두번째 원소부터 시작하고 그 앞의 원소들과 비교하여 삽입할 위치를 정하고 그 위치사이에 삽입

```
31	25	12	22	11			처음 상태.
31	[25]	12	22	11		 	두 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<25>	31	[12]	22	11		 	세 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<12>	25	31	[22]	11		 	네 번째 원소를 부분 리스트에서 적절한 위치에 삽입한다.
12	<22>	25	31	[11]		 	마지막 원소를 부분 리스트에서 적절한 위치에 삽입한다.
<11>	12	22	25	31		 	종료.
```

### Bubble, Selection, Insertion Sort 비교

| SORT   | BEST             | AVG | WORST |
|--------|------------------|-----|-------|
| Bubble | O(N<sup>2</sup>) | O(N<sup>2</sup>) | O(N<sup>2</sup>) |
| Selection | O(N<sup>2</sup>) | O(N<sup>2</sup>) | O(N<sup>2</sup>) |
| Insertion | O(N) | O(N<sup>2</sup>) | O(N<sup>2</sup>) |

3개의 정렬 방식 전부 구현이 단순하지만 O(N^2)인 정렬이므로 비효율적인 방법이라고 할 수있다

<br><br>

## 김현수

### 거품정렬 (Bubble Sort)
- 두 개의 인접한 원소를 비교하여 정렬하는 방식
- 정렬 과정(오름차순)
	1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교한다.
	2. 현재 원소가 다음 원소보다 크면 원소를 교환한다.
	3. 다음 원소로 이동하여 해당 원소와 그 다음원소를 비교한다.
- 총 라운드는 (배열 크기-1) 번 진행되고, 각 라운드별 비교 횟수는 (배열 크기-라운드 횟수)이다.
- 장점: 추가적인 메모리 소비가 적고, 구현이 매우 쉬우며, 안정 정렬이 가능하다.
- 단점: 다른 정렬 알고리즘에 비해 교환 과정이 많아 많은 시간을 소비한다.
- 시간복잡도는 O(N^2)

### 선택정렬 (Selection Sort)
- 현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘
- 정렬 과정(오름차순)
	1. 주어진 리스트에서 최솟값을 찾는다.
	2. 최솟값을 맨 앞 자리의 값과 교환한다.
	3. 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.
- 장점: 추가적인 메모리 소비가 적다.
- 단점: 안정 정렬이 아니다.
- 시간복잡도는 O(N^2)

### 삽입정렬 (Insertion Sort)
- 현재 비교하고자 하는 target(타겟)과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법
- 앞에서부터 해당 원소가 위치 할 곳을 탐색하고 해당 위치에 삽입한다. 즉, 타겟 이전 원소가 타겟 숫자보다 크기 직전까지 모든 수를 뒤로 한 칸씩 밀어낸다.
- 정렬 과정(오름차순)
	1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. (첫 번째 타겟은 두 번째 원소부터 시작한다.)
	2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
	3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다. 
- 장점: 추가적인 메모리 소비가 적으며 안정 정렬이 가능하고, 최선의 경우 O(N)의 시간복잡도를 갖는다.
- 단점: 데이터의 상태에 따라서 성능 편차가 매우 크다. (최악의 경우 O(N2)의 시간 복잡도를 갖는다.)
- 평균적인 시간 복잡도는 O(N^2)

## 우지현

### Bubble Sort (거품 정렬)

![Bubble Sort](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/bubble-sort-001.gif)

- 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘
- 가장 큰 값을 배열의 맨 끝에 이동시키면서 정렬하고자 하는 원소의 개수 만큼을 두 번 반복하게 된다.
- 정렬 과정에서 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 Bubble Sort라 지어졌다고 한다.
- 시간 복잡도
  -  `(n - 1) + (n - 2) + ... + 2 + 1 = n(n-1)/2`이므로 O(n^2)
  - 정렬이 되어있든지 안되어있든지 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간 복잡도가 O(n^2)으로 동일하다.
- 공간 복잡도
  - 주어진 배열 안에서 교환(swap)을 통해 정렬이 수행되므로 O(n)
- 장점
  - 구현이 매우 간단하고 소스코드가 직관적이다.
  - In-place sort (추가적인 메모리 공간을 많이 필요로 하지 않는 혹은 전혀 필요하지 않는 알고리즘) 
  - Stable Sort (중복된 키를 순서대로 정렬하는 정렬 알고리즘)
- 단점
  - 시간 복잡도가 최선, 평균, 최악의 경우 모두 O(n^2)이므로 굉장히 비효율적이다.
  - 정렬되어 있지 않은 원소가 정렬되었을 때의 자리로 가기 위해서 교환 연산(swap)이 많이 일어나게 된다.

### Selection Sort (선택 정렬)

![selection sort](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/selection-sort-001.gif)

- 해당 순서에 원소를 넣을 위치는 이미 정해져 있고 어떤 원소를 넣을지 선택하는 알고리즘
- 주어진 배열 중에 최솟값을 찾고 그 값을 맨 앞에 위치한 값과 교체한다. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다.
- 시간 복잡도
  - `(n - 1) + (n - 2) + ... + 2 + 1 = n(n - 1)/2`만큼의 비교가 일어나기 때문에 n개의 주어진 배열을 정렬하는데 O(n^2)만큼의 시간이 걸린다.
  - 최선, 평균, 최악의 경우 시간 복잡도는 O(n^2)로 동일하다.
- 공간 복잡도
  - 주어진 배열 안에서 교환(swap)을 통해 정렬이 수행되므로 O(n)
- 장점
  - 알고리즘이 단순하다.
  - 정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료 상태에서 비교적 효율적이다.
  - In-place sort
- 단점
  - 시간 복잡도가 O(n^2)이므로 비효율적이다.
  - Unstable Sort (동일한 key값을 정렬했을 때 순서가 바뀐다)

### Insertion Sort (삽입 정렬)

![insertion sort](https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/insertion-sort-001.gif)

- 2번째 원소부터 시작하여 왼쪽의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 알고리즘
- 손 안의 카드를 정렬하는 방법과 유사하다.
- 최선의 경우 O(n)이라는 엄청나게 빠른 효율성을 가지고 있어 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘이다.
- 시간 복잡도
  - 최악의 경우 (역으로 정렬되어 있을 경우) `(n - 1) + (n - 2) + ... + 2 + 1 = n(n - 1)/2` 즉, O(n^2)
  - 모두 정렬이 되어 있는 경우(Optimal) 한 번씩 밖에 비교를 안하므로 O(n)
  - 이미 정렬되어 있는 배열에 자료를 하나씩 합입/제거하는 경우에는 탐색을 제외한 오버헤드가 매우 적기 때문에 현실적으로 최고의 정렬 알고리즘이 된다.
  - 최선의 경우 O(n), 평균과 최악의 경우 O(n^2)
- 공간 복잡도
  - 주어진 배열 안에서 교환(swap)을 통해 정렬이 수행되므로 O(n)
- 장점
  - 알고리즘이 단순하다.
  - 대부분의 원소가 이미 정렬되어 있는 경우 매우 효율적일 수 있다.
  - In-place sort
  - Stable sort
  - Bubble Sort나 Selection Sort 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠르다.
- 단점
  - 평균과 최악의 시간 복잡도가 O(n^2)으로 비효율적이다.
  - Bubble Sort, Selection Sort와 마찬가지로 배열의 길이가 길어질수록 비효율적이다.
