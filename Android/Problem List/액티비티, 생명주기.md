# 액티비티, 생명주기

## 김민수

### 액티비티

액티비티는 4개의 앱 구성요소 중 하나로, 사용자와 **상호작용** 하기위한 진입점이다. 사용자 인터페이스를 포함한 화면 하나를 나타낸다. 하나의 앱은 여러 액티비티가 함께 작동하여 사용자 환경을 구성하지만 사실, 각 액티비티는 독립적이다. 화면을 갖는 앱의 시작점은 `AndroidManifest.xml` 파일에서 특정 액티비티의 `intent-filter`내 action, category 속성을 각각 `android.intent.action.MAIN`, `android.intent.category.LAUNCHER`로 할당하여 설정한다.

#### 수명주기

액티비티는 프로세스가 생성되면서부터 사라질 때까지 일련의 상태를 거친다. 상태 전환을 처리하는데 콜백을 사용 할 수 있다.

<img src="https://developer.android.com/guide/components/images/activity_lifecycle.png"/>

#### onCreate()

액티비티가 생성될 때 호출되는 함수로, 필수적으로 구현해야한다. 액티비티의 전체 수명주기동안 단 한번만 실행된다. 이 메서드는 `savedInstanceState`매개변수를 수신하는데, 이는 액티비티의 이전 저장 상태가 포함된 Bundle 객체이다. 만약 처음 생성된 경우 null이다.

이 메서드 내에서는 setContentView()를 실행해야 하는데 이때, layout파일의 id를 넘겨준다. 또는 View 객체를 생성하여 ViewGroup에 넣어 layout 대신 사용 할 수도 있다. (ViewBinding)

onCreate() 종료 후 상태: <u>Started</u>(visible)

#### onStart()

onStart()에서는 액티비티가 사용자에게 보여지며, 포그라운드로 올라온다. onStart 메서드는 매우 빠르게 수행되고, 시스템은 바로 onResume() 메서드를 호출한다.

onStarted() 종료 후 상태: <u>Resumed</u>(visible)

#### onResume()

Resumed 상태이면 액티비티는 포그라운드에 보이고, 시스템은 onResume()을 호출한다. 이때 액티비티는 사용자와 상호작용을 할 수 있다. 해당 액티비티가 포커스를 잃으면 액티비티의 상태는 paused로 전환된다. 시스템은 onPause()를 호출한다. Pause 상태에서 다시 전환될 때에도 onResume()이 호출된다.

#### onPause()

사용자가 액티비티에서 벗어날 때 가장 먼저 호출되는 메서드이다. 이는 액티비티가 더이상 포커스를 갖고 있지 않다는 것을 뜻한다. 이때 액티비티의 상태는 Pause(멀티 윈도우의 경우 visible, 그 외 not)가 된다. pause로 상태가 변하는 경우는 다음과 같다.

- 사용자가 액티비티를 떠나거나, 다른 이벤트로 인해 액티비티가 강제로 전환될 때 (전화)
- 멀티 윈도우 모드에서 하나의 윈도우만 포커스를 가질 수 있으므로 나머지 액티비티는 pause
- 반투명한 액티비티가 열렸을 때 - 다이얼로그

그 후 액티비티가 포커스를 다시 갖게되면 onResume()이 호출되고, 액티비티 화면이 사라지면 상태는 Stopped가 되고 onStop()이 호출된다. onPause()는 매우 빠르게 수행되므로 데이터를 저장하는 등의 무거운 작업을 수행하지 말아야한다. 그러나 pause일 때 프로세스가 종료될 수 있다. 즉, onStop() 호출 안될 수도 있다..

#### onStop()

액티비티 상태가 Stopped(invisible)가 되면 시스템은 onStop() 메서드를 호출한다. onStop()에서는 UI가 사용자에게 보이지 않으므로 필요하지 않은 리소스를 해제하거나 조정해야 한다. 또한 onStop()에서 db에 데이터 저장 등 CPU를 많이 소모하는 종료 작업을 실행해야 한다.

액티비티는 Stopped 상태에서 다시 시작되어 사용자와 상호작용 하거나 (onRestart() 호출), 프로세스를 종료하고 사라진다.(onDestroy() 호출) 

#### onDestroy()

onDestroy()가 호출될 때는 다음과 같다

- 사용자가 액티비티를 종료하거나, finish() 함수를 호출하여 종료된 경우
- 기기 회전, 멀티 윈도우 모드 등으로 시스템이 일시적으로 액티비티를 소멸하는 경우

isFinishing() 메서드는 위 두가지를 구분할 수 있다. onDestroy() 메서드는 이전의 콜백에서 아직 해제되지 않은 모든 리소스를 해제해야 한다.

#### 상태에 따른 프로세스 종료 가능성

| 종료 가능성 | 프로세스 상태                           | 액티비티 상태             |
| ----------- | --------------------------------------- | ------------------------- |
| 최소        | 포그라운드 (포커스 있거나, 가져올 예정) | Created, Started, Resumed |
| 중간        | 백그라운드 (포커스만 상실)              | pause                     |
| 최대        | 백그라운드 (보이지 않음)                | stopped                   |
| 최대        | 소멸                                    | destroyed                 |

#### 액티비티 전환 중 상태변화

한 액티비티(A)가 다른 액티비티(B)를 시작하는 경우 두 개의 액티비티 모두 수명주기가 전환된다. 이때 B 액티비티가 생성될 동안, A 액티비티는 pause 또는 stopped 상태로 전환된다. 두 액티비티가 디스크 혹은 다른 저장소에 저장된 데이터를 공유하는 경우, 주의해야할 점은 두 액티비티의 수명주기 전환이 겹쳐 일어나는 것이다.

1. A 액티비티의 onPause() 실행
2. B 액티비티의 onCreate(), onStart(), onResume() 실행
3. A 액티비티의 onStop() 실행

이와 같은 순서로 각각의 액티비티의 수명주기가 전환되므로 개발 시, 유의하며 컨트롤 할수 있어야한다.
