# 비동기 처리 방법

## 김현수

### 비동기가 필요한 이유
안드로이드에서는 UI를 그리는 메인스레드가 매우 중요하다.
애플리케이션이 실행되고 메인액티비티가 메모리에 로드되면 메인스레드를 포함한 프로세스가 생성된다.

안드로이드는 초당 60프레임을 지원하고 한 프레임은 16ms안에 그려져야 한다.
16ms 안에 화면을 그리는 작업이 완료되지 않으면 쟁크가 발생한다.
5초 이상의 긴 작업을 메인스레드에서 실행한다면 ANR이 발생한다.
> 쟁크; jank : 프레임 누락으로 인해 끊겨보이는 현상

결국 안드로이드에서 UI스레드가 원활하게 돌아가기 위해서는 비동기가 필수로 사용된다.

### AsyncTask

- 비동기(*Async*hronous)적으로 실행될 필요가 있는 작업(*Task*)을 위해 사용하는 클래스
- Thread, Handler, Message, Runnable 등을 직접 다루지 않아도, 메인 스레드와 별개로 "비동기(Asynchronous) 실행"이 필요한 작업에 사용할 수 있다.
- 주요 메서드
	- onPreExexute()
	
	  작업이 실행되기 전에 UI 스레드에서 호출. doInBackground 메소드가 실행되기 전에  프로그레스바를 보여주는 등의 필요한 초기화 작업을 하는데 사용
    
	- doInBackground(Void... params)
	
	  onPreExexute()가 실행을 마친 직후 백그라운드 스레드에서 호출. 가장 핵심적인 작업을 수행하는데 사용
    
	- onPostExecute(String result)
	
	  doInBackground()가 끝난 후에 UI 스레드에서 호출.doInBackground의 리턴 값을 매개변수로 받아 처리
    
	- onCancelled()
	
	  doInBackground() 수행 중이나 메이스레드에서 cancel(true)를 호출하면 호출되며, 주로 작업의 진행 상태를 프로그래스바로 표시하기 위해 사용
	
> AsyncTask는 Android 11부터 Deprecated됨

### RxJava

- Reactive Programming을 자바에서 구현하기 위해서 등장한 라이브러리
> Reactive Programming(반응형 프로그래밍) : 비동기 데이터 흐름을 중시하는 프로그래밍으로 외부에서 자유롭게 데이터 입출력을 하여도 메인쓰레드와 방해하지 않는것을 중시하는 프로그래밍
- 관찰 가능한(Observable) 스트림을 사용하는 비동기 프로그래밍을 위한 API이다.
- RxJava의 사용을 위해서는 App단의 build.gradle에 다음을 implementation 해야 한다.
```
implementation 'io.reactivex.rxjava2:rxandroid:2.1.1'
implementation 'io.reactivex.rxjava2:rxjava:2.2.15'
```
 

### Coroutine

- Coroutine은 안드로이드 개발자 문서에서 공식적으로 AsyncTask 대신 사용할 것을 권하고 있다.
- Coroutine의 사용을 위해서는 App단의 build.gradle에 다음을 implementation 해야 한다.
```
implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.0'
implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0'
```
## 김민수

### 안드로이드에서 비동기 처리

안드로이드에서 UI와 사용자 입력 처리는 메인 스레드가 담당한다. 만약 메인 스레드가 아주 긴 시간동안 어떤 작업을 처리해야 한다면, 사용자는 앱이 멈춰있다라고 느낄 것이다. 또한 시스템에서도 메인 스레드가 5초 이상 응답하지 않으면 ANR 다이얼로그를 띄운다. 따라서 긴 작업을 처리해야 하는 경우, 비동기 작업이 필요하다. 안드로이드에서 비동기 처리는 3가지 방법이 있다.

- 워커 스레드 생성
- AsyncTask 사용
- Coroutine 사용

### 워커 스레드

``` kotlin
//in activity class

val workerThread = Thread {
	override fun run() {
    //do something and..
    Handler(Looper.getMainLooper()).post {
      //do ui work
    } //or
    runOnUiThread {
      // do ui work
    } //or
    View.post {
      // do ui Work
    }
  }
}

workerThread.start()
```

워커 스레드에서 뷰에 접근하면 `CalledFromWrongthreadException`이 발생한다. 따라서 메인 스레드에게 UI작업을 넘겨줘야하는 데 이때, 3가지 방법이 있다.

- 메인 스레드의 핸들러에 post(Runnable) 실행
- Activity.runOnUiThread(Runnable) 실행
- View.post(Runnable) 실행

워커 스레드는 액티비티의 생명주기를 넘어서서 지속될 수 있다. 따라서 수동적으로 워커 스레드의 생명주기를 관리해 줄 필요가 있다.

### AsyncTask

<img src="https://t1.daumcdn.net/cfile/tistory/2420B240577D4A720F" width=600/>

- AsyncTask들의 작업은 모두 단 하나의 스레드에서 처리되므로 비교적 짧은 task처리에 알맞다. 만약 병렬 처리를 원한다면 `myTask.executeOnExcutor(AsyncTask.THREAD_POOL_EXECUTOR)`로 호출하면 된다.
- `doInBackground()`를 제외한 나머지 함수들은 메인 스레드에서 실행되므로, UI 컴포넌트 접근이 가능하다.
- `AsyncTask.execute()`로 실행하고 `doInBackground(), onProgressUpdate(), onPostExcuted()` 를 직접 호출하면 안된다.

- Android 11에서 Deprecated 되었다.

### Coroutine

- 적절한 코루틴 콘텍스트를 통해 코루틴 스코프를 지정하여 알맞은 작업을 비동기적으로 수행할 수 있다.
- 기본적으로 코루틴 스코프도 액티비티 생명주기를 무시하며 실행된다. 따라서 액티비티 수명주기에 취소해야 할 경우, CoroutineScope.cancel()을 호출해야 한다.
- 
