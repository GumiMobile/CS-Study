# SOLID

## 우지현

### SOLID

객체 지향의 4대 특성인 캡슐화, 상속, 추상화, 다형성을 이용하여 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙들이다. SOLID는 클래스 안의 응집도는 높이고 타 클래스들 간의 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다. 좋은 소프트웨어는 응집도가 높고 결합도가 낮기 때문이다. 결국 모듈 또는 클래스 당 하나의 책임을 주어 더욱더 독립된 모듈(클래스)을 만들기 위함이다. 이렇게 설계된 소프트웨어는 재사용이 많아지고 수정이 최소화되기 때문에 유지 보수와 확장이 용이해진다.

#### OOP를 실세계에서 설명하려면?

1. OOP 4대 특성 (추상화, 상속, 캡슐화, 다형성) : 주방도구
2. OOD (객체 지향 설계) 5원칙 : 주방 도구 설명서
3. DP (디자인 패턴) : 레시피

### SRP (Single Responsibility Principle, 단일 책임 원칙)

> "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." - 로버트 C. 마틴

클래스와 메소드는 하나의 역할만 하도록 한다.

변화의 시기와 이유가 다르면 클래스는 분리해야 한다. 즉, 관련되어 있는 책임만 주라는 것이다. 

SRP는 속성, 메소드, 패키지, 모듈, 컴포넌트, 프레임워크에게 단일 책임을 주고, 독립적으로 모듈화시키는 것이다.

|                         SRP 적용 전                          |                         SRP 적용 후                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541862421739.png"> | <img src="https://sehun-kim.github.io/sehun/assets/images/1541913074849.png"> |

### OCP (Open Closed Principle, 개방 폐쇄 원칙)

> "소프트웨어 엔티티(패키지, 클래스, 모듈, 함수 등)는 확장에 대해서는 개방되어야 하지만, 변경에 대해서는 폐쇄되어야 한다." - 로버트 C. 마틴

자신의 확장에서는 개방되어 있고, 주변의 변화에 대해서는 폐쇄되어 있어야 한다.

|                         OCP 적용 전                          |                         OCP 적용 후                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541913936787.png"><br /><img src="https://sehun-kim.github.io/sehun/assets/images/1541913944420.png"><br />운전자는 마티즈와 쏘나타의 변화에 따라 행동이 의존적으로 변하게 된다. 이와 같이 직접적으로 클래스의 메서드를 호출하고 결합도를 높게 설계했다면 확장적이지 못할 뿐더러 많은 수정이 발생되어 유지 보수가 어려워진다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541913950879.png"><br />마티즈, 쏘나타의 상위에 자동차라는 상위 클래스를 둔다. 이렇게 되면 자동차 클래스는 하위에 다른 차종을 상속하여 확장할 수 있고, 운전자는 그 변경 사항에 전혀 영향을 받지 않을 수 있다. |

OCP는 상위 클래스 또는 인터페이스를 중간에 두어 직접적인 연동을 피하게 설계한다. 하나 더 예를 들자면 아래 그림에서와 같이 오라클, MySQL, MS-SQL에 모두 확장적(개방적)이면서 자바 애플리케이션 입장에서 수정은 폐쇄적이다.

<div align="left"><img src="https://sehun-kim.github.io/sehun/assets/images/1541914244823.png"></div>

### LSP (Liskov Substitution Principle, 리스코프 치환 원칙)

> "서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다." - 로버트 C. 마틴

서브 타입은 언제나 자신의 상위 타입으로 교체할 수 있어야 한다.

객체지향에서 상속은 조직도, 계층도가 아니라 분류도가 되어야 한다.

- 하위 클래스 is a kind of 상위 클래스 : 하위 분류는 상위 분류의 한 종류이다.
- 구현 클래스 is able to 인터페이스 : 구현 분류는 인터페이스 할 수 있어야 한다.

LSP는 하위 클래스가 상위 클래스 역할을 대신할 때 논리적으로 맞아 떨어져야 한다.

|                        LSP 위반 사례                         |                     LSP를 잘 구현한 사례                     |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541915202328.png"><br />딸은 아버지의 역할을 할 수 없다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541915209305.png"><br />박쥐는 포유류의 역할을 할 수 있다. |

### ISP (Interface Segregation Principle, 인터페이스 분리 원칙)

> "클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다." - 로버트 C. 마틴

ISP는 SRP와 같은 원인에 대해 다른 해결책을 제시하는 것이다. 너무 많은 책임을 주어 상황에 관련되지 않은 메소드까지 구현했다면, SRP는 그 클래스를 여러 개의 클래스로 나눈다. 하지만 ISP는 해당 클래스를 그냥 둔 상태에서 인터페이스 최소 주의 원칙에 따라 각 상황에 맞는 기능만 제공하도록 필터링한다고 생각하면 된다.

|                             SRP                              |                             ISP                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541913074849.png"><br />역할마다 클래스를 분리한다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541915738069.png"><br />다양한 역할을 인터페이스로 만들고 각 역할에 맞는 메소드만 제공한다. |

#### 빈약한 상위 클래스 vs 풍성한 상위 클래스

<div align="left"><img src="https://sehun-kim.github.io/sehun/assets/images/1541916340635.png"></div>

상위 클래스가 풍성할수록 캐스팅(Casting)이 적게 일어나서 소스 코드가 깔끔해진다. 그렇기 때문에 상위 클래스가 풍성할수록 좋다.

### DIP (Dependency Inversion Principle, 의존 역전 원칙)

> "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
>
> "추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
>
> "자주 변경되는 구체(Concrete) 클래스에 의존하면 안 된다."
>
> -로버트 C. 마틴

자신보다 변하기 쉬운 것에 의존하지 마라.

- 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 크다.
- 하위 클래스나 구체 클래스가 아닌 더 추상적인 것에 의존하라는 것이  의존 역전 원칙이다.

구체적인 클래스는 코딩에 있어서 가장 전면적으로 노출되고 사용되기 때문에 변화에 민감하다. 만약 DIP에 의해 설계하지 않는다면, 구체화된 클래스가 수정될 때마다 상위 클래스나 추상 클래스가 변화해야 하는데 그렇게 되면 연관되어 있는 모든 상위 클래스들이 수정되어야 한다. 따라서 하위 클래스나 구체 클래스에 의존하면 안된다.

DIP를 구현하는 한가지 방법이 DI(Dependency Injection)이다.

|                         DIP 적용 전                          |                         DIP 적용 후                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541916908016.png"><br />자동차는 스노우타이어에 의존하고 있다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541917299687.png"><br />해당 의존 관계를 타이어 인터페이스를 사용하여 역전시킨다.<br />즉, 구체적인 스노우타이어에 의존하던 것을 추상적인 타이어에 의존하는 것으로 변경했다. |

## 김민수

### SOLID

### 단일 책임 원칙 - Single Responsibility

> 같은 이유로 변경될 코드들은 모으고, 다른 이유로 변경될 코드들은 흩어라

**모든 메서드 또는 클래스는 단 하나의 책임을 가져야한다**.

```java
public class CarService() {

    public void findCarById(String query) {
        // DB에서 찾아오기..
        // Log 파일에 찾은 정보 쓰기..
    }

}
```

위 메서드는 DB에서 책을 찾고 찾아온 정보를 log에 기록하는 2가지의 일을 한다. 이런 메서드는 단일 책임 원칙에 위배된다. 단일 책임 원칙에 맞게 수정하면 아래와 같다.

``` java
public class CarService() {

    public String findCarById(String query) {
        // DB에서 찾아오기..
    }

    public void WriteLog(String log) {
        // Log 파일에 찾은 정보 쓰기..
    }
}
```

### 개방 폐쇄 원칙 - Open-Closed

> 모듈은 확장에 열려있고, 변경에는 닫혀있어야 한다

**소프트웨어의 entity(클래스, 모듈, 메서드)의 확장은 권장하지만 기존 모듈의 수정은 권장하지 않는다.**

``` java
void checkOut(Receipt receipt) {
  // 영수증의 금액 취합
  Money total = Money.zero;
  for (item : items) {
    total += item.getPrice();
    receipt.addItem(item);
  }
  // 현금으로 계산
  Payment p = acceptCash(total);
  receipt.addPayment(p);
}
```

이때 카드 결제를 추가한다면 checkOut 메서드는 반드시 수정을 해야한다. 따라서 위 예시는 개방 폐쇄 원칙에 위배된다. 아래 예시는 개방 폐쇄 원칙에 맞게 수정된 코드이다.

``` java
interface PaymentMethod {
    Payment acceptPayment(Money total);
}

class PaymentCash {
    public Payment acceptPayment(Money total){
        // 현금 계산 구현
    }
}

class PaymentCreditCard {
    public Payment acceptPayment(Money total){
        // 신용카드 계산 구현
    }
}

void checkOut(Receipt receipt, PaymentMethod method) {
  // 영수증의 금액 취합
  Money total = Money.zero;
  for (item : items) {
    total += item.getPrice();
    receipt.addItem(item);
  }

  // function을 호출할 때 함께 들어오는 PaymentMethod Type으로 어떻게 계산할지가 정해진다.
  Payment p = method.acceptPayment(total);
  receipt.addPayment(p);
}
```

더욱 적절한 예시는 jdbc 드라이버 매니저이다. jdbc 드라이버는 다른 DB에 개방적(확장성)이면서 자바 어플리케이션 입장에서 폐쇄적(DB에 따라 수정이 필요치 않는)이다.

<img src="http://etutorials.org/shared/images/tutorials/tutorial_47/13fig01.gif"/>

### 리스코프 치환 원칙 - Liskov Substitution

> 인터페이스를 사용하는 프로그램은 그 인터페이스의 구현체에 의해 동작이 바뀌면 안된다

**부모 자식 클래스 관계 혹은 인터페이스와 클래스 관계에서, 하위 클래스의 행위는 상위클래스의 행위의 범위 내에서 이루어져야한다.**

즉, 하위클래스는 상위클래스의 역할을 대체하는데 문제가 없어야 한다.



잘못된 상속관계 : 아버지, 아들

아들은 아버지의 종류가 아니다. 아들은 아버지의 속성, 역할을 전부 포함하지 않는다.

올바른 상속관계 : 포유류, 고양이

고양이는 포유류의 한 종류이다.

고양이는 포유류의 속성, 역할을 전부 포함한다.



### 인터페이스 분리 원칙 - Interface Segregation

> 사용자가 필요하지 않은 것들에 의존하지 않도록 인터페이스를 작게 유지하라

**인터페이스를 각 용도에 맞게 분리해야 한다.**

인터페이스를 지나치게 범용적으로 구현한다면 그 인터페이스를 상속받은 클래스는 자신이 필요하지 않은 메서드마저도 구현해야한다. 또한 필요치 않은 인터페이스 메서드가 변경되면 상속받은 클래스는 해당 메서드를 사용하지 않음에도 변경이 필요하다. 따라서 이는 인터페이스 분리 원칙에 위배된다.



### 의존 역전 원칙 - Dependency Inversion

> 추상화하는 방향으로 의존하라. 상위 레벨 모듈이 하위 레벨 세부사항에 의존하면 안된다

**자신보다 변하기 쉬운 것에 의존하지 마라. 추상클래스, 상위 클래스는 하위 클래스에 의존적이면 안된다. 하위 클래스는 가장 전면에서 사용되고 변화에 민감하기 때문이다.**



<img src="https://miro.medium.com/max/1044/1*7y1fn5uBV0v7YgiRtIIang.png"/>



한 전사는 칼, 활, 창을 사용한다. 이 때, 전사가 사용하는 무기의 종류는 변하기 쉬운 것이다. 따라서 칼, 활, 창을 추상화하는 무기라는 개념을 사용한다.

<img src="https://miro.medium.com/max/1336/1*LnYJyEPbu6sKSrLDlBivfQ.png"/>

위 예시에서는 구체적인 무기를 직접 의존했던 것과는 달리 무기라는 추상화된 개념을 의존한다. 또한 칼, 활, 창은 무기라는 개념을 상속한다. 따라서 추상클래스를 이용하여 의존 관계를 역전시켰다.

변하기 쉬운 것에 의존하던 것을 상위 개념을 의존하여 변화에 영향을 받지 않는 것을 의존 역전 원칙이라 한다.


## 이수형

### SOLID

### 단일 책임 원칙

작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는데 집중되어야 함

적용방법

   1. Divergent change 

      - 개별클래스로 분할하여 클래스당 하나의 책임만을 맡도록함
      - 책임만 분리하는것이 아니고 분리된 두 클래스간의 관계의 복잡도도 줄이도록 설계해야함

   2. Shotgun surgery

      - 산발적으로 여러곳에 분포된 책임들을 한곳에 모으면서 설계를 깨끗하게 함 (응집성을 높힘)

주의할점

- 각 클래스는 하나의 개념을 나타내야함
- 무조건 책임을 분리한다고 되는것이 아니라 개체간의 응집력과 결합력에 따라 결정해야함
 
### 개방폐쇄의 원칙

소프트웨어의 구성요소(컴포넌트,클래스,모듈,함수)는 확장에는 열려있고 변경에는 닫혀있여야 함

적용방법

1.  변경(확장)될 것과 변하지 않을것을 엄격히 구분

2. 두 모듈이 만나는 지점에 인터페이스를 정의

3. 구현에 의존하기 보다는 정의한 인터페이스에 의존하도록 작성

주의할점

- 인터페이스 설계에서 적절한 크기조절과 예측이 필요함

### 리스코브 치환의 원칙

서브타입은 언제나 상위 타입으로 교체할 수 있어야함 즉 하위클래스가 상위 클래스의 모든 규약을 지켜야함

적용 방법

- 만약 두 개체가 같은 일을 한다면 둘을 하나의 클래스로 표현하고 구분할수 있는 필드를 둠

- 똑같은 연산을 제공하지만 약간씩 다르게 한다면 공통의 인터페이스를 두고 이를 구현

- 공통된 연산이 없다면 완전 별개의 클래스로 나눔

- 두 개체가 하는일에 추가적으로 더 하려면 extends를 이용

주의할점

- 혼동될 여지가 없으면 그대로 둠
- 리스코브 치환원칙을 지키기 어렵다면 상속대신 합성을 사용

### 인터페이스 분리의 원칙

한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함 즉 최소한의 인터페이스만을 사용해야한다는 것

적용 방법

- 클래스 인터페이스를 통한 분리(상속을 이용)
- 객체 인터페이스를 통한 분리(위임을 이용)
> 위임 : 특정일의 책임을 다른 클래스나 메소드에 맡기는것

주의할점

- 두개 이상의 인터페이스가 공유하는 부분의 재사용을 극대화해야함
- 서로다른 성격의 인터페이스를 명백히 분리해야함

### 의존성역전의 원칙

자신보다 변하기 쉬운 하위 레벨 모듈에 의존적이면 안됨 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 의미역전이 일어나기때문

적용 방법

- 레이어를 통한 구조화
   - 상위레벨의 레이어가 하위 레벨의 레이어를 바로 의존하는 것이 아니라 이 둘사이에 존재하는 추상레벨을 통해 의존해야함


## 윤기재

### SOLID
> 객체지향을 올바르게 설계할수있도록 도와주는 원칙들이다. 
- SOLID 원칙들은 자기자신의 클래스안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High - Cohesion Loose Coupling 원칙을 도입한것이다.


### SRP (Single Responsibility Principle) 단일 책임 원칙
> 객체는 단하나의 책임만 가져야 한다는 원칙

- 클래스에 모든 기능을 다넣기 보다는 목적과 취지에 맞도록 관련된 책임만 주도록 하는것

- 즉, 속성 메서드 모듈, 컴포넌트 , 프레임워크를 단일책임으로 주고 독립적으로 모듈화 시키는 것이 SRP(단일책임) 원칙이다.

### OCP (Open Closed Principle) 개방 폐쇄 원칙
> 기존의 코드를 변경하지 않고 기능을 추가할수 있도록 설계해야 하는 원칙

- 자신의 확장에서는 개방되어있고, 주변의 변화에 대해서는 패쇄되어 있어야한다.

- 즉, 구현된 클래스를 이용하기 보다는 Interface 나 abstract class 를 만들어 완충제 역할을 하도록한다.

ex) JDBC Driver Manager 

### LSP (Liskov Substitution Principle) 리스코프 치환 원칙
> 자식 클래스는 최소한 부모 클래스의 기능은 수행할수있어야 한다는 원칙

- 서브 타입은 언제나 자신의 상위타입으로 교체할 수 있어야한다.

- LSP 는 하위 클래스가 사위 클래스 역할을 대신할 때 논리적으로 맞아 떨어져야한다.

### ISP (Interface Segregation Principle) 인터페이스 분리 원칙
> 자신이 사용하지 않는 인터페이스와 의존관계를 맺거나 영향을 받지 않아야 한다는 원칙

- SRP 로 인해 너무 많은 클래스 구현을 불러일으킬때, 다양한 역할들을 Interface 로 만들고 Interface는 해당 역할만 구현하면 된다.



### DIP (Dependency Inversion Principle) 의존 역전 원칙
> 의존관계 성립시 추상성이 높은 클래스와 의존 관계를 맺어야 하는 원칙

- 하위클래스나 구체클래스가 아닌 더 추상적인 것에 의존하라는 것이 의존 역전 원칙이다.
- 만약 DIP 가 지켜지지 않는 다면 클래스가 수정 될떄마다 상위클래스들이 수정 되어야한다.
- 따라서 자신보다 변하기 쉬운 것에 의존하던것을 인터페이스나 상위클래스를 두어 하위 클래스의 변화에 영향을 받지 않도록 설계한다.

<br><br>
## 이유진
### SRP(Single Responsibility Principle) 단일 책임 원칙
클래스를 변경해야 하는 이유는 하나다.  
왜냐하면 한 클래스당 하나의 책임을 갖기 때문이다. 책임이 많아지면, 한 책임의 변화가 다른 책임에 영향을 주게 된다.  
책임을 적절히 분배함으로써 코드의 가독성을 높이고, 유지보수에 용이해진다.

### OCP(Open Closed Principle) 개방 폐쇄 원칙
소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 대해 열려있지만, 변경에는 닫혀 있어야 한다.  
요구사항의 변경이나 추가사항이 발생할 때, 기존 구성요소는 수정이 일어나지 말아야 한다. 단, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다.  
이는 관리가능하고 재사용 가능 한 코드를 만드는 기반이 되고, 객체지향의 장점을 극대화하는 중요한 원리라고 할 수 있다.

### LSP(Liskov Substitution Principle) 리스포크 치환 원칙
상위 객체의 타입을 하위 객체의 타입으로 변경했을 때, 작동에 이상이 없어야 한다. 즉, 하위 객체의 타입이 상위 객체의 타입과 클라이언트간의 규약(인터페이스)을 지켜야 한다.  
LSP를 바탕으로 OCP는 확장하는 부분에 다형성을 제공해 변화에 열려있는 프로그램을 만들 수 있도록 한다.

### ISP(Interface Segregation Principle) 인터페이스 분리 원칙
클라이언트는 자신과 관련이 없는 메서드에 의존하지 않아야 한다.  
따라서 큰 덩어리의 인터페이스들을 역할 인터페이스(구체적이고 작은 단위)로 분리시켜서 클라이언트들이 꼭 필요한 메서드만 이용할 수 있도록 한다. 이를 통해 시스템 내부 의존성을 약화시켜 리팩토링, 수정, 재배포에 용이해진다.  
SRP가 클래스의 단일책임이라면, ISP는 인터페이스의 단일 책임을 강조한다.

### DIP(Dependency Inversion Principle) 의존 역전 원칙
의존 관계를 맺을 때 자신보다 변하기 어려운 것에 의존해야 한다.  
추상클래스 또는 상위클래스는 구체적인 구현클래스나 하위클래스에 의존하면 안 된다. 구체적인 클래스는 가장 전면에 노출되고 사용되기 때문에 변화에 민감하기 때문이다. 만약 DIP에 의해 설계하지 않는다면, 구체화된 클래스가 수정될 때마다 이를 상속하는 추상(또는 상위)클래스가 변화하게 되고, 이와 연관 되어있는 클래스들이 다 수정되어야 하기 때문이다.   

> 예) 컴퓨터 클래스가 있다. 이 컴퓨터는 현재 `Windows운영체제`를 의존하고 있다. 하지만 서버 개발이 하고싶어서 `Linux운영체제`로 바꾸게 되면, 그에 맞춰 컴퓨터 클래스도 변하게 된다. 따라서 Windows와 Linux의 추상화된 인터페이스인 `운영체제`를 의존하여 운영체제가 바뀌어도 수정 가능성을 낮춰야 한다.

> #### 정리
> SRP + ISP => 객체가 커지는 것을 막는다.
> OCP + LSP + DIP => 추상화의 기반이 된다.
