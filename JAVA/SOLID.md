# SOLID

## 우지현

### SOLID

객체 지향의 4대 특성인 캡슐화, 상속, 추상화, 다형성을 이용하여 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙들이다. SOLID는 클래스 안의 응집도는 높이고 타 클래스들 간의 결합도는 낮추는 High Cohesion - Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것이다. 좋은 소프트웨어는 응집도가 높고 결합도가 낮기 때문이다. 결국 모듈 또는 클래스 당 하나의 책임을 주어 더욱더 독립된 모듈(클래스)을 만들기 위함이다. 이렇게 설계된 소프트웨어는 재사용이 많아지고 수정이 최소화되기 때문에 유지 보수와 확장이 용이해진다.

#### OOP를 실세계에서 설명하려면?

1. OOP 4대 특성 (추상화, 상속, 캡슐화, 다형성) : 주방도구
2. OOD (객체 지향 설계) 5원칙 : 주방 도구 설명서
3. DP (디자인 패턴) : 레시피

### SRP (Single Responsibility Principle, 단일 책임 원칙)

> "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다." - 로버트 C. 마틴

클래스와 메소드는 하나의 역할만 하도록 한다.

변화의 시기와 이유가 다르면 클래스는 분리해야 한다. 즉, 관련되어 있는 책임만 주라는 것이다. 

SRP는 속성, 메소드, 패키지, 모듈, 컴포넌트, 프레임워크에게 단일 책임을 주고, 독립적으로 모듈화시키는 것이다.

|                         SRP 적용 전                          |                         SRP 적용 후                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541862421739.png"> | <img src="https://sehun-kim.github.io/sehun/assets/images/1541913074849.png"> |

### OCP (Open Closed Principle, 개방 폐쇄 원칙)

> "소프트웨어 엔티티(패키지, 클래스, 모듈, 함수 등)는 확장에 대해서는 개방되어야 하지만, 변경에 대해서는 폐쇄되어야 한다." - 로버트 C. 마틴

자신의 확장에서는 개방되어 있고, 주변의 변화에 대해서는 폐쇄되어 있어야 한다.

|                         OCP 적용 전                          |                         OCP 적용 후                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541913936787.png"><br /><img src="https://sehun-kim.github.io/sehun/assets/images/1541913944420.png"><br />운전자는 마티즈와 쏘나타의 변화에 따라 행동이 의존적으로 변하게 된다. 이와 같이 직접적으로 클래스의 메서드를 호출하고 결합도를 높게 설계했다면 확장적이지 못할 뿐더러 많은 수정이 발생되어 유지 보수가 어려워진다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541913950879.png"><br />마티즈, 쏘나타의 상위에 자동차라는 상위 클래스를 둔다. 이렇게 되면 자동차 클래스는 하위에 다른 차종을 상속하여 확장할 수 있고, 운전자는 그 변경 사항에 전혀 영향을 받지 않을 수 있다. |

OCP는 상위 클래스 또는 인터페이스를 중간에 두어 직접적인 연동을 피하게 설계한다. 하나 더 예를 들자면 아래 그림에서와 같이 오라클, MySQL, MS-SQL에 모두 확장적(개방적)이면서 자바 애플리케이션 입장에서 수정은 폐쇄적이다.

<div align="left"><img src="https://sehun-kim.github.io/sehun/assets/images/1541914244823.png"></div>

### LSP (Liskov Substitution Principle, 리스코프 치환 원칙)

> "서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다." - 로버트 C. 마틴

서브 타입은 언제나 자신의 상위 타입으로 교체할 수 있어야 한다.

객체지향에서 상속은 조직도, 계층도가 아니라 분류도가 되어야 한다.

- 하위 클래스 is a kind of 상위 클래스 : 하위 분류는 상위 분류의 한 종류이다.
- 구현 클래스 is able to 인터페이스 : 구현 분류는 인터페이스 할 수 있어야 한다.

LSP는 하위 클래스가 상위 클래스 역할을 대신할 때 논리적으로 맞아 떨어져야 한다.

|                        LSP 위반 사례                         |                     LSP를 잘 구현한 사례                     |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541915202328.png"><br />딸은 아버지의 역할을 할 수 없다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541915209305.png"><br />박쥐는 포유류의 역할을 할 수 있다. |

### ISP (Interface Segregation Principle, 인터페이스 분리 원칙)

> "클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다." - 로버트 C. 마틴

ISP는 SRP와 같은 원인에 대해 다른 해결책을 제시하는 것이다. 너무 많은 책임을 주어 상황에 관련되지 않은 메소드까지 구현했다면, SRP는 그 클래스를 여러 개의 클래스로 나눈다. 하지만 ISP는 해당 클래스를 그냥 둔 상태에서 인터페이스 최소 주의 원칙에 따라 각 상황에 맞는 기능만 제공하도록 필터링한다고 생각하면 된다.

|                             SRP                              |                             ISP                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541913074849.png"><br />역할마다 클래스를 분리한다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541915738069.png"><br />다양한 역할을 인터페이스로 만들고 각 역할에 맞는 메소드만 제공한다. |

#### 빈약한 상위 클래스 vs 풍성한 상위 클래스

<div align="left"><img src="https://sehun-kim.github.io/sehun/assets/images/1541916340635.png"></div>

상위 클래스가 풍성할수록 캐스팅(Casting)이 적게 일어나서 소스 코드가 깔끔해진다. 그렇기 때문에 상위 클래스가 풍성할수록 좋다.

### DIP (Dependency Inversion Principle, 의존 역전 원칙)

> "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
>
> "추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
>
> "자주 변경되는 구체(Concrete) 클래스에 의존하면 안 된다."
>
> -로버트 C. 마틴

자신보다 변하기 쉬운 것에 의존하지 마라.

- 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 크다.
- 하위 클래스나 구체 클래스가 아닌 더 추상적인 것에 의존하라는 것이  의존 역전 원칙이다.

구체적인 클래스는 코딩에 있어서 가장 전면적으로 노출되고 사용되기 때문에 변화에 민감하다. 만약 DIP에 의해 설계하지 않는다면, 구체화된 클래스가 수정될 때마다 상위 클래스나 추상 클래스가 변화해야 하는데 그렇게 되면 연관되어 있는 모든 상위 클래스들이 수정되어야 한다. 따라서 하위 클래스나 구체 클래스에 의존하면 안된다.

DIP를 구현하는 한가지 방법이 DI(Dependency Injection)이다.

|                         DIP 적용 전                          |                         DIP 적용 후                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <img src="https://sehun-kim.github.io/sehun/assets/images/1541916908016.png"><br />자동차는 스노우타이어에 의존하고 있다. | <img src="https://sehun-kim.github.io/sehun/assets/images/1541917299687.png"><br />해당 의존 관계를 타이어 인터페이스를 사용하여 역전시킨다.<br />즉, 구체적인 스노우타이어에 의존하던 것을 추상적인 타이어에 의존하는 것으로 변경했다. |





