# Database

- [데이터베이스](#데이터베이스)
- [Index](#index)
  - [Primary Index vs Secondary Index](#primary-index-vs-secondary-index)
  - [Composite Index](#composite-index-결합-인덱스)

<br /><br />

## 데이터베이스

DB 사용 이전에는 데이터를 각각의 파일로 저장하며 데이터를 관리하였으나 다음과 같은 여러 문제점들이 있어 DB가 등장함

- 중복성 문제 : 각 파일마다 필요한 데이터를 각각 가지고 있어야 하므로 효율이 없다
- 무결성 문제 : 데이터를 프로그램과 상관없이 쉽게 변형 가능해서 무결성을 유지하기 힘듦
- 종속성 문제 : 여러 개의 프로그램이 데이터 파일을 공유할 경우 한 프로그램이 새로운 데이터를 추가하거나 삭제하면 다른 프로그램도 기능과 관계없이 프로그램을 수정해야함
- 동시 접근문제 : 여러 개의 프로그램이 공유하는 경우 동시접근이 허용되지 않고 스케줄러로 관리해야함
- 장애 복구 문제: 프로그램이 데이터를 갱신하다가 장애가 생겼을 경우 파일처리 시스템은 작업이 어디까지 되었는지 알려줄 수가 없어서 스스로 해결해야함

### 데이터베이스란?

데이터베이스 시스템 : 특정 업무에 필요한 다양한 형태의 데이터를 모아놓은 데이터의 집합체

데이터베이스 관리 시스템 : 모든 응용프로그램들이 DB를 공유할 수 있도록 관리해주는 소프트웨어(ex. SQL, MySQL, Oracle 등)

데이터베이스의 구성요소 : 데이터베이스, DBMS, 데이터 언어, 데이터베이스 관리, 일반 사용자

데이터베이스의 특징

- 데이터의 독립성
 - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다
 - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
- 데이터의 무결성 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
- 데이터의 보안성 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
- 데이터의 일관성 연관된 정보를 논리적인 구조로 관리함으로서 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
- 데이터 중복 최소화 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

데이터베이스의 장점

- SQL 문장만 익히면 프로그램으로 일일이 구현해야 했던 것들을 명령어만으로 수행할 수 있다.
- 자료의 무결성을 보장한다.
- 하나의 데이터베이스에 여러 응용 프로그램이 접근할 수 있어서 재사용성이 증가
- 단일 table에 대해서도 구조적으로 데이터를 저장하여 활용할 수 있지만, 더 큰 장점은 여러 table에 산발적으로 퍼진 데이터를 개발자의 입맛대로 병합하여 사용할 수 있음
- 데이터를 특정 기준에 따라 정렬해서 사용할 수 있음
- 데이터를 한 데 모아 데이터베이스에 대한 보안을 강화함으로써 비용이 절감되고 보안성이 향상

데이터베이스의 단점

- 문서(pdf, doc, hwp등) , 이미지(jpg, gif 등), 압축(zip,rar 등) 등의 바이너리 파일의 처리가 어렵다.
- 바이너리 파일을 DB에 올리면서 오랜 시간 접속을 유지한다면 그만큼 다른 유저가 사용할 수 없고, 결국은 DB에서 감당할 수 있는 유저의 수가 줄어든다.
- DB에 바이너리 파일이 들어가면 백업 시간이 많이 늘어나 원하는 시간 안에 백업을 하지 못하는 일이 발생할 수 있다.


데이터베이스의 성능

데이터베이스 성능 조정은 시스템 자원을 가장 적절하게 사용하여 쿼리의 응답 시간을 최소화하기 위해 수행된다. 자원을 적절하게 사용하려면 네트워크 트래픽, 디스크 I/O, CPU 시간 최소화가 필요하다.
이때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.
현실에서는 대부분의 I/O 작업이 랜덤 I/O이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#database)

<br />

## Index

### Primary Index vs Secondary Index

Primary Index (기본 인덱스)

- 기본키를 포함하는 인덱스
  - 기본키는 테이블의 하나의 레코드를 대표하는 컬럼 값으로 식별자로 쓰인다.
  - 그렇기 때문에 NULL과 중복을 허용하지 않는다.
- 키의 순서가 레코드의 순서를 결정한다.
- 인덱스가 레코드와 직접적으로 연결되어 위치를 결정한다.
- 테이블당 하나만 생성 가능하다.
- 기본 인덱스는 두 필드로 이루어진 정렬된 데이터이다.
  - 첫 번째 필드는 기본키를 복사하고 정렬된 데이터의 순서로 정렬된다.
  - 두 번째 필드는 실제 데이터를 가리키는 포인터이다.
  - 각 블럭의 첫 번째 레코드는 `앵커 레코드` 혹은 `블럭 앵커`라 한다.

Secondary Index (보조 인덱스)

- 기본 인덱스 이외의 인덱스
- 키의 순서가 레코드의 순서를 의미하지는 않는다.
- 레코드의 위치를 알려주는 역할을 한다.
- 테이블당 여러 개 가질 수 있다.
- Primary Key 이외에 필요한 정렬 기준이 있을 경우 사용한다.
- 보조 인덱스는 일반적으로 밀집 인덱스이므로, 기본 인덱스를 사용하는 경우보다 디스크 접근 횟수가 증가한다.

### Composite Index (결합 인덱스)

- 인덱스를 생성할 때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것
- 주로 SQL 문장에서 WHERE절의 조건 컬럼이 2개 이상 AND로 연결되어 함께 사용되는 경우에 많이 사용된다.
- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들로 인덱스를 구성할 수 있다.
- 두 개 이상의 조건이 OR로 조회되는 경우는 결합 인덱스를 만들면 안된다.
- 결합 인덱스를 구성할 때는 컬럼의 순서가 중요하다! (아래 예시 참고)
- 장점
  - 나쁜 분포도를 가진 컬럼을 결합하면 더 좋은 분포도로 개선할 수 있다.
  - 저장공간의 효율성이 좋아진다.

> ```mysql
> SELECT *
> FROM emp
> WHERE name = "Aron"(150/1000건) AND gender = "M"(550/1000건)
> ```
>
> 위 예시에서 이름과 성별을 조건으로 한다. 이때, 많은 데이터를 걸러낼 수 있는 조건 순서로 결합 인덱스를 구성한다. 
>
> 1. 성별 -> 이름 : 1000건 중 'M' 550건을 찾아내고, 그 중 'Aron'을 검사한다. => 150건
> 2. 이름 -> 성별 : 1000건 중 'Aron' 150건을 찾아내고, 그 중 'M'을 검사한다. => 150건
>
> 2번이 첫 번째 조건에서 많은 데이터를 걸러내므로 두 번째 검사를 할 때 효율성이 더 높다. 아래는 이름과 성별 순서대로 결합 인덱스를 생성하는 예시이다.
>
> ```mysql
> CREATE INDEX idx_emp_comp
> ON emp( name, gender );
> ```

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#database)

<br />
