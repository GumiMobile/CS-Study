# Database

- [데이터베이스](#데이터베이스)
- [Index](#index)
  - [인덱스란? 인덱스의 자료구조](#인덱스란? 인덱스의-자료구조)
  - [Primary Index vs Secondary Index](#primary-index-vs-secondary-index)
  - [Composite Index](#composite-index-결합-인덱스)

<br /><br />

## 데이터베이스

DB 사용 이전에는 데이터를 각각의 파일로 저장하며 데이터를 관리하였으나 다음과 같은 여러 문제점들이 있어 DB가 등장함

- 중복성 문제 : 각 파일마다 필요한 데이터를 각각 가지고 있어야 하므로 효율이 없다
- 무결성 문제 : 데이터를 프로그램과 상관없이 쉽게 변형 가능해서 무결성을 유지하기 힘듦
- 종속성 문제 : 여러 개의 프로그램이 데이터 파일을 공유할 경우 한 프로그램이 새로운 데이터를 추가하거나 삭제하면 다른 프로그램도 기능과 관계없이 프로그램을 수정해야함
- 동시 접근문제 : 여러 개의 프로그램이 공유하는 경우 동시접근이 허용되지 않고 스케줄러로 관리해야함
- 장애 복구 문제: 프로그램이 데이터를 갱신하다가 장애가 생겼을 경우 파일처리 시스템은 작업이 어디까지 되었는지 알려줄 수가 없어서 스스로 해결해야함

### 데이터베이스란?

데이터베이스 시스템 : 특정 업무에 필요한 다양한 형태의 데이터를 모아놓은 데이터의 집합체

데이터베이스 관리 시스템 : 모든 응용프로그램들이 DB를 공유할 수 있도록 관리해주는 소프트웨어(ex. SQL, MySQL, Oracle 등)

데이터베이스의 구성요소 : 데이터베이스, DBMS, 데이터 언어, 데이터베이스 관리, 일반 사용자

데이터베이스의 특징

- 데이터의 독립성
 - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다
 - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
- 데이터의 무결성 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
- 데이터의 보안성 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
- 데이터의 일관성 연관된 정보를 논리적인 구조로 관리함으로서 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
- 데이터 중복 최소화 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

데이터베이스의 장점

- SQL 문장만 익히면 프로그램으로 일일이 구현해야 했던 것들을 명령어만으로 수행할 수 있다.
- 자료의 무결성을 보장한다.
- 하나의 데이터베이스에 여러 응용 프로그램이 접근할 수 있어서 재사용성이 증가
- 단일 table에 대해서도 구조적으로 데이터를 저장하여 활용할 수 있지만, 더 큰 장점은 여러 table에 산발적으로 퍼진 데이터를 개발자의 입맛대로 병합하여 사용할 수 있음
- 데이터를 특정 기준에 따라 정렬해서 사용할 수 있음
- 데이터를 한 데 모아 데이터베이스에 대한 보안을 강화함으로써 비용이 절감되고 보안성이 향상

데이터베이스의 단점

- 문서(pdf, doc, hwp등) , 이미지(jpg, gif 등), 압축(zip,rar 등) 등의 바이너리 파일의 처리가 어렵다.
- 바이너리 파일을 DB에 올리면서 오랜 시간 접속을 유지한다면 그만큼 다른 유저가 사용할 수 없고, 결국은 DB에서 감당할 수 있는 유저의 수가 줄어든다.
- DB에 바이너리 파일이 들어가면 백업 시간이 많이 늘어나 원하는 시간 안에 백업을 하지 못하는 일이 발생할 수 있다.


데이터베이스의 성능

데이터베이스 성능 조정은 시스템 자원을 가장 적절하게 사용하여 쿼리의 응답 시간을 최소화하기 위해 수행된다. 자원을 적절하게 사용하려면 네트워크 트래픽, 디스크 I/O, CPU 시간 최소화가 필요하다.
이때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉, 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.
현실에서는 대부분의 I/O 작업이 랜덤 I/O이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#database)

<br />

## Index

### 인덱스란? 인덱스의 자료구조

#### 인덱스란?

인덱스는 DBMS가 파일 내의 특정 레코드들을 빠르게 찾을 수 있도록 하는 데이터 구조이다. Table의 컬럼을 따로 정렬하고 파일로 저장하면 레코드 탐색 시 Index 파일을 통해 빠르게 값을 찾을 수 있다.

장점

- 자주 사용되는 컬럼을 인덱싱하면 더 빠르게 데이터에 접근할 수 있다.

단점

- 인덱스는 항상 정렬된 상태를 유지해야 하므로 CUD작업을 수행하면 성능이 떨어진다.
- 인덱스를 저장할 추가적인 공간이 더 필요하다.

#### 인덱스의 자료구조

#### Hash Table

- 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 빠르게 데이터를 검색할 수 있는 자료구조이다.
- 해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이다.
- 해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색한다.
- Hash Table을 사용하게 된다면 등호(=)이 아닌 부등호 연산의 경우에 문제가 발생한다.
- 동등 연산(=)에 특화된 Hash Table은 데이터베이스의 자료구조로 적합하지 않다.

#### Balaced Tree

#### B-Tree

한쪽으로 데이터가 쏠릴 수 있는 이진 탐색 트리의 한계를 극복하고자 나온 자료구조이다. 탐색 시 O(lon N)의 시간 복잡도를 갖는다. B-Tree는 루트, 브랜치, 리프 노드로 구성된다.

- B-tree의 각 노드의 키는 정렬된 상태여야 한다

- 키 사이에 자식 노드가 연결되어 있는데 자식 노드는 부모 노드 키의 사이 값만 가져야 한다.

  ex - 8, 25 사이의 자식 노드는 15,21,23 이다.

<img src="https://camo.githubusercontent.com/66d022ac91748a77f02a019736dc97023568e11317e12535e4b5450c37dbd24e/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f63696b656c6c2f62747142527644553178462f43644968766738584568484b615032337645344a75312f696d672e6a7067" style width="600"/>

#### B+Tree

B-Tree의 확장 개념으로, B-Tree의 경우, 브랜치 노드에 key와 data를 담을 수 있다. 하지만 B+Tree는 브랜치 노드에 key만 담아두고 리프 노드에 key와 data를 저장한다. 리프 노드끼리 Linked list로 연결되어 있다.

<img src="https://camo.githubusercontent.com/1e33f09a71f247101c07043d3fecb3672dbeb6d2cdbba745c89716743194c10a/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6252694c31392f62747142544d53424357462f4a336e4b773271796d705556784754686e56644c4b302f696d672e706e67" style width="600"/>



#### B-Tree vs B+Tree

|             | B-Tree                              | B+Tree                                   |
| ----------- | ----------------------------------- | ---------------------------------------- |
| 키 저장     | 리프, 브랜치                        | 리프, 브랜치                             |
| 데이터 저장 | 리프, 브랜치                        | 리프                                     |
| 트리의 높이 | 높음                                | 낮음 (한 노드당 key를 많이 담을 수 있음) |
| 풀 스캔     | 모든 노드 탐색                      | 리프 노드에서 선형탐색                   |
| 키 중복     | 없음                                | 있음 (리프 노드에 모든 데이터 저장)      |
| 검색        | Best case는 루트 노드에서 검색 가능 | 무조건 리프 노드까지 탐색                |



### Primary Index vs Secondary Index

Primary Index (기본 인덱스)

- 기본키를 포함하는 인덱스
  - 기본키는 테이블의 하나의 레코드를 대표하는 컬럼 값으로 식별자로 쓰인다.
  - 그렇기 때문에 NULL과 중복을 허용하지 않는다.
- 키의 순서가 레코드의 순서를 결정한다.
- 인덱스가 레코드와 직접적으로 연결되어 위치를 결정한다.
- 테이블당 하나만 생성 가능하다.
- 기본 인덱스는 두 필드로 이루어진 정렬된 데이터이다.
  - 첫 번째 필드는 기본키를 복사하고 정렬된 데이터의 순서로 정렬된다.
  - 두 번째 필드는 실제 데이터를 가리키는 포인터이다.
  - 각 블럭의 첫 번째 레코드는 `앵커 레코드` 혹은 `블럭 앵커`라 한다.

Secondary Index (보조 인덱스)

- 기본 인덱스 이외의 인덱스
- 키의 순서가 레코드의 순서를 의미하지는 않는다.
- 레코드의 위치를 알려주는 역할을 한다.
- 테이블당 여러 개 가질 수 있다.
- Primary Key 이외에 필요한 정렬 기준이 있을 경우 사용한다.
- 보조 인덱스는 일반적으로 밀집 인덱스이므로, 기본 인덱스를 사용하는 경우보다 디스크 접근 횟수가 증가한다.

### Composite Index (결합 인덱스)

- 인덱스를 생성할 때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것
- 주로 SQL 문장에서 WHERE절의 조건 컬럼이 2개 이상 AND로 연결되어 함께 사용되는 경우에 많이 사용된다.
- 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들로 인덱스를 구성할 수 있다.
- 두 개 이상의 조건이 OR로 조회되는 경우는 결합 인덱스를 만들면 안된다.
- 결합 인덱스를 구성할 때는 컬럼의 순서가 중요하다! (아래 예시 참고)
- 장점
  - 나쁜 분포도를 가진 컬럼을 결합하면 더 좋은 분포도로 개선할 수 있다.
  - 저장공간의 효율성이 좋아진다.

> ```mysql
> SELECT *
> FROM emp
> WHERE name = "Aron"(150/1000건) AND gender = "M"(550/1000건)
> ```
>
> 위 예시에서 이름과 성별을 조건으로 한다. 이때, 많은 데이터를 걸러낼 수 있는 조건 순서로 결합 인덱스를 구성한다. 
>
> 1. 성별 -> 이름 : 1000건 중 'M' 550건을 찾아내고, 그 중 'Aron'을 검사한다. => 150건
> 2. 이름 -> 성별 : 1000건 중 'Aron' 150건을 찾아내고, 그 중 'M'을 검사한다. => 150건
>
> 2번이 첫 번째 조건에서 많은 데이터를 걸러내므로 두 번째 검사를 할 때 효율성이 더 높다. 아래는 이름과 성별 순서대로 결합 인덱스를 생성하는 예시이다.
>
> ```mysql
> CREATE INDEX idx_emp_comp
> ON emp( name, gender );
> ```

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#database)

<br />
