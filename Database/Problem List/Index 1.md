# Index1 (Index란, Index의 자료구조)
## 이유진
### Index란?
`rowid`를 기준으로 데이터를 탐색할 수 있도록 유도해서 쿼리의 성능을 향상시키기 위해 만든 자료구조 (책 뒷부분의 **색인**과 같다.)  
특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장한다. 이 인덱스를 사용하여, 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져옴으로써 검색 속도를 향상시킨다.
![image](https://user-images.githubusercontent.com/37680108/136246636-c49e98c6-6fe8-4682-9441-cb2f55276138.png)
(이미지출처 https://coding-factory.tistory.com/746)

#### 장점
- 인덱스에는 데이터들이 정렬되어 있다. -> 데이터를 빠르게 찾을 수 있다.
    - `Where절`의 효율성, `Order by절`의 효율성, `Min`, `Max`의 효율적인 처리

#### 단점
- 정렬된 상태를 계속 유지시켜줘야 된다. 
레코드 내에 데이터값이 바뀌면 Index 테이블 내에 있는 값들 정렬 필요 => 결과적으로 원본 테이블, index 테이블 두 군데 수정
- 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에는 효과적이지만, 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.
- 데이터베이스의 약 10%에 해당하는 추가 저장공간 필요

### Index의 자료구조
가장 많이 사용하는 구조는 `Balanced Tree Index` 구조이다. 특히 `B*TREE`와 `B+TREE` 구조를 가장 많이 사용한다. (Oracle도 사용) Balanced Tree의 탐색 시간복잡도가 항상 O(log N)이기 때문이다. 

#### Hash?
Hash의 탐색 시간복잡도는 O(1)이지만, 특정 데이터 하나를 탐색하는 시간이다. 또한, 정렬되어있지 않아서 범위에 해당되는 값을 조회할 때는 시간이 오래 걸리기 때문에 Index에 사용하기는 비효율적이다.

#### B-tree?
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdeYkf3%2Fbtq6LOy2zhZ%2FVpbOWpElW1lrEsXPgbJgp1%2Fimg.png)
(이미지출처  https://helloinyong.tistory.com/296)

하나의 노드에 여러 데이터가 저장 가능한 트리이다. Root-Branch-Leaf의 형태를 갖고 있고, 노드 내의 데이터들은 정렬된 상태를 유지한다. (배열과 비슷한 모습인데, 실제로 메모리 상에 연속적으로 저장되어있다. => 포인터 접근 감소 => 연속된 데이터에 접근 속도 향상) DB인덱스를 B-Tree로 구성할 경우 leaf Node에 rowID를 저장한다.

따라서, B-tree를 사용하는 이유는
1. 모든 데이터가 정렬된 상태를 유지하므로, 부등호(`>`, `<`) 연산 처리 가능
2. 포인터 접근 방식이 적어 매우 많은 데이터가 있어도 속도 이슈가 적다.
3. 삽입, 수정, 삭제에도 O(log N)의 시간 복잡도를 가짐. (== 배열로 인덱스를 만들지 않는 이유)

## 김민수

### Index

인덱스는 DBMS가 파일 내의 특정 레코드들을 빠르게 찾을 수 있도록 하는 데이터 구조이다. Table의 컬럼을 따로 정렬하고 파일로 저장하여 검색 시 해당 Table의 레코드를 Index 파일을 검색하여 속도를 빠르게 한다.

![img](https://ssup2.github.io/images/theory_analysis/DB_Indexing/DB_Indexing.PNG)

#### 장점

- 자주 사용되는 칼럼을 인덱싱하면 더 빠르게 데이터에 접근할 수 있음

#### 단점

- 인덱스는 정렬시켜 놓은 자료이므로 insert, update 등 수정 작업을 할 때 속도가 저하된다.
- 인덱스를 저장할 추가적인 공간이 더 필요하다. (10%의 출처는??)

### 인덱스의 자료구조

#### Balaced Tree 

#### B-Tree

한쪽으로 데이터가 쏠릴 수 있는 이진 탐색 트리의 한계를 극복하고자 나온 자료구조이다. 탐색 시 O(lon N)의 시간 복잡도를 갖는다. B-Tree는 루트, 브랜치, 리프 노드로 구성된다.

- B-tree의 각 노드의 키는 정렬된 상태여야 한다

- 키 사이에 자식 노드가 연결되어 있는데 자식 노드는 부모 노드 키의 사이 값만 가져야 한다.

  ex - 8, 25 사이의 자식 노드는 15,21,23 이다.

![img](https://blog.kakaocdn.net/dn/cikell/btqBRvDU1xF/CdIhvg8XEhHKaP23vE4Ju1/img.jpg)

#### B+Tree

B-Tree의 확장 개념으로, B-Tree의 경우, 브랜치 노드에 key와 data를 담을 수 있다. 하니잠 B+Tree는 브랜치 노드에 key만 담아두고 리프 노드에 key와 data를 저장한다. 리프 노드끼리 Linked list로 연결되어 있다.

![img](https://blog.kakaocdn.net/dn/bRiL19/btqBTMSBCWF/J3nKw2qympUVxGThnVdLK0/img.png)

#### B-Tree vs B+Tree

|             | B-Tree                              | B+Tree                                   |
| ----------- | ----------------------------------- | ---------------------------------------- |
| 키 저장     | 리프, 브랜치                        | 리프, 브랜치                             |
| 데이터 저장 | 리프, 브랜치                        | 리프                                     |
| 트리의 높이 | 높음                                | 낮음 (한 노드당 key를 많이 담을 수 있음) |
| 풀 스캔     | 모든 노드 탐색                      | 리프 노드에서 선형탐색                   |
| 키 중복     | 없음                                | 있음 (리프 노드에 모든 데이터 저장)      |
| 검색        | Best case는 루트 노드에서 검색 가능 | 무조건 리프 노드까지 탐색                |

## 이수형

### INDEX

인덱스는 추가적인 쓰기작업과 저장공간을 활용하여 DB 테이블의 검색속도를 향상시키기 위한 자료구조이다<br/>
DBMS는 인덱스를 항상 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색 가능하다

장점

- 테이블 조회속도와 성능이 향상된다.

단점

- 인덱스를 관리하기 위한 추가공간이 필요

- 인덱스를 관리하는 추가 작업이 필요
- CUD를 많이 하는 속성에 인덱스를 걸면 오히려 성능이 저하된다

인덱스의 사용

- 규모가 큰 테이블

- Join이나 where 또는 order by에 자주 사용되는 컬럼
- 삽입,삭제,갱신이 자주 발생하지 않는 컬럼


인덱스의 자료구조

해시테이블, Balanced Tree 구조 등을 사용하며 주로 Balanced Tree를 사용한다.

B- Tree

- B-Tree에 저장된 데이터들은 항상 정렬된 상태로 유지되기 때문에 부등호 연산에 대한 효율적인 데이터 탐색이 가능

- 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가짐

B+ Tree

- B-Tree를 확장시킨 자료구조

- 리프 노드를 제외하고 Value를 담아두지 않기 때문에 노드의 메모리에 더 많은 Key를 저장할 수 있음(트리의 높이가 낮아짐)
- 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다

## 우지현

### Index란?

- 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인
- 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호
- DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 그래서 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 둔다.
- DBMS의 인덱스는 항상 정렬된 상태를 유지한다.
  - 원하는 값을 탐색하는 것은 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다.
  - 결론적으로 DBMS의 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.
- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### Index 자료구조

#### B+-Tree Index 알고리즘

- 일반적으로 사용되는 인덱스 알고리즘
- 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리) 원래의 값을 이용해 인덱싱하는 알고리즘

#### Hash Index 알고리즘

- 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
- 하지만 값을 변형해서 인덱싱하므로 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.
- 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

#### 왜 index를 생성하는데 B-Tree를 사용하는가?

- 데이터에 접근하는 시간복잡도가 O(1)인 Hash Table이 더 효율적일 것 같지만 그렇지 않다.
- SELECT 질의 조건에는 부등호 연산(<, >)도 포함된다.
- Hash Table을 사용하게 된다면 등호(=)이 아닌 부등호 연산의 경우에 문제가 발생한다.
- 동등 연산(=)에 특화된 Hash Table은 데이터베이스의 자료구조로 적합하지 않다.


## 윤기재

### INDEX 란?

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는것은 오랜 시간이 걸린다. 그렇기 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.

#### INDEX 의 특징
- 데이터의 탐색을 빠르게하는데 쓰인다.
- 정렬 되어있다. 
- 새로운 데이터가 추가, 삭제, 변경되면 이에 상응하는 인덱스를 추가,삭제, 변경해야한다.

#### INDEX 의 단점
- 정렬된 상태를 유지해야 하기때문에 Insert, update 속도가 저하됨
- 테이블 외에 인덱스 테이블값도 갱신해야하기 떄문에 성능에 부정적 일수있음


### INDEX 의 자료구조

#### B-Tree 인덱스
- B -Tree 는 균형트리이다.
- O(logN) 의 시간 복잡도를 가진다.
- B-tree 처음 생성 당시는 균형 트리이지만 테이블 갱신(INSERT/UPDATE/DELETE)의 반복을 통해 서서히 균형이 깨지고, 성능도 악화된다.  

#### B+Tree 인덱스
- 리프노드끼리 링크드리스트로 연결되어있다.
- 리프노드를 제외하고 데이터를 담아두지 않기 떄문에 더 많은 Key들을 수용할수있다.
- full scan 시, B+tree는 리프노드에 데이터가 있기떄문에 한번의 선형탐색으로 B-tree 보다 좋은 성능을 가진다.

#### Hash Table
- 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 빠르게 데이터를 검색할 수 있는 자료구조이다. 
- 해시 테이블이 빠른 검색속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문이다.
- 해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색한다.

##### Hash Table 특징
- 각각의 Key 값은 고유한 index 를 가지게되어 접근할수있으므로 평균 O(1) 의 시간복잡도를 가진다.
- 테이블이 가득차면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러일으킨다.
