# Index1 (Index란, Index의 자료구조)
## 이유진
### Index란?
`rowid`를 기준으로 데이터를 탐색할 수 있도록 유도해서 쿼리의 성능을 향상시키기 위해 만든 자료구조 (책 뒷부분의 **색인**과 같다.)  
특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장한다. 이 인덱스를 사용하여, 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져옴으로써 검색 속도를 향상시킨다.
![image](https://user-images.githubusercontent.com/37680108/136246636-c49e98c6-6fe8-4682-9441-cb2f55276138.png)
(이미지출처 https://coding-factory.tistory.com/746)

#### 장점
- 인덱스에는 데이터들이 정렬되어 있다. -> 데이터를 빠르게 찾을 수 있다.
    - `Where절`의 효율성, `Order by절`의 효율성, `Min`, `Max`의 효율적인 처리

#### 단점
- 정렬된 상태를 계속 유지시켜줘야 된다. 
레코드 내에 데이터값이 바뀌면 Index 테이블 내에 있는 값들 정렬 필요 => 결과적으로 원본 테이블, index 테이블 두 군데 수정
- 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에는 효과적이지만, 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.
- 데이터베이스의 약 10%에 해당하는 추가 저장공간 필요

### Index의 자료구조
가장 많이 사용하는 구조는 `Balanced Tree Index` 구조이다. 특히 `B*TREE`와 `B+TREE` 구조를 가장 많이 사용한다. (Oracle도 사용) Balanced Tree의 탐색 시간복잡도가 항상 O(log N)이기 때문이다. 

#### Hash?
Hash의 탐색 시간복잡도는 O(1)이지만, 특정 데이터 하나를 탐색하는 시간이다. 또한, 정렬되어있지 않아서 범위에 해당되는 값을 조회할 때는 시간이 오래 걸리기 때문에 Index에 사용하기는 비효율적이다.

#### B-tree?
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdeYkf3%2Fbtq6LOy2zhZ%2FVpbOWpElW1lrEsXPgbJgp1%2Fimg.png)
(이미지출처  https://helloinyong.tistory.com/296)

하나의 노드에 여러 데이터가 저장 가능한 트리이다. Root-Branch-Leaf의 형태를 갖고 있고, 노드 내의 데이터들은 정렬된 상태를 유지한다. (배열과 비슷한 모습인데, 실제로 메모리 상에 연속적으로 저장되어있다. => 포인터 접근 감소 => 연속된 데이터에 접근 속도 향상) DB인덱스를 B-Tree로 구성할 경우 leaf Node에 rowID를 저장한다.

따라서, B-tree를 사용하는 이유는
1. 모든 데이터가 정렬된 상태를 유지하므로, 부등호(`>`, `<`) 연산 처리 가능
2. 포인터 접근 방식이 적어 매우 많은 데이터가 있어도 속도 이슈가 적다.
3. 삽입, 수정, 삭제에도 O(log N)의 시간 복잡도를 가짐. (== 배열로 인덱스를 만들지 않는 이유)

## 김민수

### Index

인덱스는 DBMS가 파일 내의 특정 레코드들을 빠르게 찾을 수 있도록 하는 데이터 구조이다. Table의 컬럼을 따로 정렬하고 파일로 저장하여 검색 시 해당 Table의 레코드를 Index 파일을 검색하여 속도를 빠르게 한다.

![img](https://ssup2.github.io/images/theory_analysis/DB_Indexing/DB_Indexing.PNG)

#### 장점

- 자주 사용되는 칼럼을 인덱싱하면 더 빠르게 데이터에 접근할 수 있음

#### 단점

- 인덱스는 정렬시켜 놓은 자료이므로 insert, update 등 수정 작업을 할 때 속도가 저하된다.
- 인덱스를 저장할 추가적인 공간이 더 필요하다. (10%의 출처는??)

### 인덱스의 자료구조

#### Balaced Tree 

#### B-Tree

한쪽으로 데이터가 쏠릴 수 있는 이진 탐색 트리의 한계를 극복하고자 나온 자료구조이다. 탐색 시 O(lon N)의 시간 복잡도를 갖는다. B-Tree는 루트, 브랜치, 리프 노드로 구성된다.

- B-tree의 각 노드의 키는 정렬된 상태여야 한다

- 키 사이에 자식 노드가 연결되어 있는데 자식 노드는 부모 노드 키의 사이 값만 가져야 한다.

  ex - 8, 25 사이의 자식 노드는 15,21,23 이다.

![img](https://blog.kakaocdn.net/dn/cikell/btqBRvDU1xF/CdIhvg8XEhHKaP23vE4Ju1/img.jpg)

#### B+Tree

B-Tree의 확장 개념으로, B-Tree의 경우, 브랜치 노드에 key와 data를 담을 수 있다. 하니잠 B+Tree는 브랜치 노드에 key만 담아두고 리프 노드에 key와 data를 저장한다. 리프 노드끼리 Linked list로 연결되어 있다.

![img](https://blog.kakaocdn.net/dn/bRiL19/btqBTMSBCWF/J3nKw2qympUVxGThnVdLK0/img.png)

#### B-Tree vs B+Tree

|             | B-Tree                              | B+Tree                                   |
| ----------- | ----------------------------------- | ---------------------------------------- |
| 키 저장     | 리프, 브랜치                        | 리프, 브랜치                             |
| 데이터 저장 | 리프, 브랜치                        | 리프                                     |
| 트리의 높이 | 높음                                | 낮음 (한 노드당 key를 많이 담을 수 있음) |
| 풀 스캔     | 모든 노드 탐색                      | 리프 노드에서 선형탐색                   |
| 키 중복     | 없음                                | 있음 (리프 노드에 모든 데이터 저장)      |
| 검색        | Best case는 루트 노드에서 검색 가능 | 무조건 리프 노드까지 탐색                |


## 이수형

### INDEX

인덱스는 추가적인 쓰기작업과 저장공간을 활용하여 DB 테이블의 검색속도를 향상시키기 위한 자료구조이다<br/>
DBMS는 인덱스를 항상 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색 가능하다

장점

- 테이블 조회속도와 성능이 향상된다.

단점

- 인덱스를 관리하기 위한 추가공간이 필요

- 인덱스를 관리하는 추가 작업이 필요
- CUD를 많이 하는 속성에 인덱스를 걸면 오히려 성능이 저하된다

인덱스의 사용

- 규모가 큰 테이블

- Join이나 where 또는 order by에 자주 사용되는 컬럼
- 삽입,삭제,갱신이 자주 발생하지 않는 컬럼


인덱스의 자료구조

해시테이블, Balanced Tree 구조 등을 사용하며 주로 Balanced Tree를 사용한다.

B- Tree

- B-Tree에 저장된 데이터들은 항상 정렬된 상태로 유지되기 때문에 부등호 연산에 대한 효율적인 데이터 탐색이 가능

- 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가짐

B+ Tree

- B-Tree를 확장시킨 자료구조

- 리프 노드를 제외하고 Value를 담아두지 않기 때문에 노드의 메모리에 더 많은 Key를 저장할 수 있음(트리의 높이가 낮아짐)
- 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다

