# Index1 (Index란, Index의 자료구조)
## 이유진
### Index란?
`rowid`를 기준으로 데이터를 탐색할 수 있도록 유도해서 쿼리의 성능을 향상시키기 위해 만든 자료구조 (책 뒷부분의 **색인**과 같다.)  
특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장한다. 이 인덱스를 사용하여, 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져옴으로써 검색 속도를 향상시킨다.
![image](https://user-images.githubusercontent.com/37680108/136246636-c49e98c6-6fe8-4682-9441-cb2f55276138.png)
(이미지출처 https://coding-factory.tistory.com/746)

#### 장점
- 인덱스에는 데이터들이 정렬되어 있다. -> 데이터를 빠르게 찾을 수 있다.
    - `Where절`의 효율성, `Order by절`의 효율성, `Min`, `Max`의 효율적인 처리

#### 단점
- 정렬된 상태를 계속 유지시켜줘야 된다. 
레코드 내에 데이터값이 바뀌면 Index 테이블 내에 있는 값들 정렬 필요 => 결과적으로 원본 테이블, index 테이블 두 군데 수정
- 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에는 효과적이지만, 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.
- 데이터베이스의 약 10%에 해당하는 추가 저장공간 필요

### Index의 자료구조
가장 많이 사용하는 구조는 `Balanced Tree Index` 구조이다. 특히 `B*TREE`와 `B+TREE` 구조를 가장 많이 사용한다. (Oracle도 사용) Balanced Tree의 탐색 시간복잡도가 항상 O(log N)이기 때문이다. 

#### Hash?
Hash의 탐색 시간복잡도는 O(1)이지만, 특정 데이터 하나를 탐색하는 시간이다. 또한, 정렬되어있지 않아서 범위에 해당되는 값을 조회할 때는 시간이 오래 걸리기 때문에 Index에 사용하기는 비효율적이다.

#### B-tree?
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdeYkf3%2Fbtq6LOy2zhZ%2FVpbOWpElW1lrEsXPgbJgp1%2Fimg.png)
(이미지출처  https://helloinyong.tistory.com/296)

하나의 노드에 여러 데이터가 저장 가능한 트리이다. Root-Branch-Leaf의 형태를 갖고 있고, 노드 내의 데이터들은 정렬된 상태를 유지한다. (배열과 비슷한 모습인데, 실제로 메모리 상에 연속적으로 저장되어있다. => 포인터 접근 감소 => 연속된 데이터에 접근 속도 향상) DB인덱스를 B-Tree로 구성할 경우 leaf Node에 rowID를 저장한다.

따라서, B-tree를 사용하는 이유는
1. 모든 데이터가 정렬된 상태를 유지하므로, 부등호(`>`, `<`) 연산 처리 가능
2. 포인터 접근 방식이 적어 매우 많은 데이터가 있어도 속도 이슈가 적다.
3. 삽입, 수정, 삭제에도 O(log N)의 시간 복잡도를 가짐. (== 배열로 인덱스를 만들지 않는 이유)
