# 메모리 관리 전략2 (Paging)

## 김현수

### Paging (페이징)

- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 
- 물리 메모리는 **Frame**이라는 고정 크기로 분리되어 있고, 논리 메모리는 **Page**라 불리는 고정 크기의 블록으로 분리된다. 
- 하나의 프로세스가 사용하는 공간은 여러 페이지로 나뉘어 관리되고 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다.
- Page table이 페이지와 프레임의 주소를 관리하며, page table의 인덱스 수는 page 수와 같다.
- 논리 주소는 페이지 번호(p)와 변위(d), 물리 주소는 프레임 번호(f)+변위(d)로 표현된다.
- 페이징을 통해 논리 메모리는 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절하게 배치됨으로 외부 단편화 해결

- 단점 
	- 할당이 항상 프레임의 정수 배로 할당되기 때문에 역으로 내부 단편화의 비중이 증가한다.
		> ex) 페이지 크기가 1,024B이고 Process A가 3,172B의 메모리를 요구한다면 
		총 4개의 페이지 프레임( 3개의 페이지 프레임(1,024 * 3 = 3,072) + 100B )이 필요하다.
		4번쩨 페이지 프레임에는 924B(1,024 - 100)의 여유공간이 남게 되는 내부 단편화 문제가 발생한다.
	- 내부 단편화를 감소시키기 위해 페이지 크기를 줄이면, 페이지 테이블이 커지게 된다.
	- page table이 메모리에 올라가있기 때문에 데이터나 명령문에 접근하기 위해서는 두번의 메모리 access가 일어난다.(페이지 테이블에 한번, 페이지 테이블을 통해 실제 메모리에 한번)

## 이수형

### 페이징

외부 단편화 과정에서 process가 조각난 메모리보다 커서 못들어가는것이 단편화 발생의 이유<br/>
즉 조각난메모리와 프로세스의 크기를 동일하게 맞춰준다면? 공간이 들어맞지 않을까 라는 아이디어에서 파생<br/>
이때까지는 프로세스가 연속적으로 할당되어야한다는 관념때문에 하나의 프로세스가 쭉 수행되는 것을 실행해왔으나 페이징 기법으로 메모리 낭비를 크게 줄임<br/>

- 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방식
- 동일한 크기로 잘라 연석적으로 배치하지 않아도 되기에 외부단편화가 사라짐
- 내부단편화는 생길 수 있음
- 물리 메모리를 고정크기 사이즈로 나눈것 -> 프레임
- 논리 메모리를 고정크기 사이즈로 나눈것 -> 페이지

### page mapping table
페이징을 이용하면 이제 선형적이지 않으므로 이를 연결해줄 mapping table이 필요함 이것은 배열처럼 인데스가 페이지 번호를 가르키고 그 배열에 담고있는 숫자가 매핑할 프레임 번호가 되는것<br/>
하나의 프로세서는 32비트 프로세서에서 페이지 오프셋이 12비트이므로 2^20개 이상의 페이지를 표현할수 없음<br/>
또한 이 테이블을 저장할 곳이 CPU의 MMU에 넣을순 없으니(비용문제) RAM에 넣는데 그러면 메모리를 1번 갈려고 메모리를 2번접근해야하는 비효율이생김 이 성능문제로 인해 TLB가 나옴<br/>

### TLB

페이지 테이블이 2^20개나 있지만 실제로는 거의다 안쓰고 거의 쓰는 영역만 쓴다는점에 초점을 맞춤<br/>
그래서 이를 캐시메모리를 이용하여 성능을 향상시킨것 page 몇개에 대한정보만 갖다가 저장시킴<br/>
이러면 속도와 크기가 모두 만족스러운 성능이 됨

## 우지현

### Paging (페이징)

![Paging](https://t1.daumcdn.net/cfile/tistory/27649A47590818AA2D)

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 프로세스가 점유하는 논리 메모리는 Page라 불리는 고정 크기의 블록으로 분리된다.

- Frame(프레임) : 실제 메모리 공간 (4KB)
- Page(페이지) : 프로세스의 메모리 공간 (4KB)
- 프레임 사이즈 = 페이지 사이즈
- 논리적 의미와 관계 없이 크기가 모두 동일하다

하나의 프로세스가 사용하는 공간은 논리 메모리에서 여러 개의 페이지로 나뉘어서 관리되고, 개별 페이지는 **순서에 상관없이** 물리 메모리에 있는 프레임에 mapping되어 저장된다.

### 장점과 단점

- 장점
  - 페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있다.
- 단점
  - 내부 단편화 문제의 비중이 늘어나게 된다.
    - 예를 들어 페이지 크기가 1,024B이고 프로세스 A가 3,172B의 메모리를 요구한다면 3개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B가 남기 때문에 총 4개의 페이지 프레임이 필요한 것이다.
    - 결론적으로 4번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하게 된다.

## 김민수

### 페이징

- 논리 주소를 같은 크기(32bit 체제에서 4kb)로 잘라(**페이지**) 페이지 테이블을 이용하여 물리 주소(**프레임**)에 할당함

- 페이지 테이블은 용량이 매우 커 메모리에 저장

- 결국 데이터에 접근하려면 **<u>페이지 테이블</u>에 1번**, **<u>실제 데이터</u>에 1번** 총 **<u>2번</u>** 접근해야함

- 속도향상을 위해 고속 캐시(하드웨어)인 TLB(translation look-aside buffer)를 사용함

  TLB 전체 병렬 검색 후, TLB에 없으면 페이지 테이블에서 주소 찾음

- 페이지, 테이블, TLB는 프로세스마다 생성


## 윤기재

### Paging(페이징)
- 외부단편화와 압축작업을 해소하기 위해 생긴 방법.
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 해제
- 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재하는 방식
- 물리 메모리는 (Frame) 이라는 고정 크기로 분리되어있고, 논리 메모리(Page)는 페이지라 불리는 고정 크기의 블록으로 분리된다.
- 내부단편화가 일어날수있음

#### 가상 메모리 페이징
- 단순 페이징과 비교해서 프로세스 페이지 전부를 로드시킬 필요가없음
- 필요한 페이지가 있으면 후에 자동적으로 불러들어짐

	- 장점
	외부단편화가없음
	다중 프로그래밍 정도가 높으며 가상 주소 공간이 큼

	- 단점
	복잡한 메모리 관리 오버헤드

