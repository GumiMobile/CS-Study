# 메모리 관리 전략1 (메모리 관리 배경)

## 김현수

### 메모리 관리 배경

각각의 프로세스는 독립된 메모리 공간을 가진다.
운영체제는 각 프로세스들을 메모리 각각의 공간에 할당하고, 프로세스가 다른 프로세스에 접근하는 것을 막는다.
운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 자유롭다.

### 1. 주소 바인딩
- 주소 바인딩이란 프로세스가 접근해야 하는 값과 함수에 대한 주소가 정해지는 것을 말한다.
- 논리 주소(=가상 주소) : CPU가 명령문을 실행함으로써 발생하는 주소
- 물리 주소: 실제 접근해야 하는 메모리 주소
- 논리 주소와 물리 주소는 프로그램이 실행되는 과정 중 어느 시점에 바인딩이 되는지에 따라 다르다.
	- 컴파일 시점 주소 바인딩 : 컴파일 될 때 컴파일러에서 명령어들과 변수의 메모리 주소가 정해지는 것. `논리 주소 == 물리 주소`
	- 로드 시점 주소 바인딩 : 프로그램이 컴파일 되고 메모리에 올라갈 때 CPU에서 주소 계산이 일어난 후 주소가 발생하는 것. `논리 주소 == 물리 주소`
	- 실행 시점 주소 바인딩 : 매번 명령어가 실행될때마다 주소가 계산되는 것. `논리 주소 != 물리 주소`
	
### 2. Swapping
프로그램은 컴파일 후 메모리에 올리는 로드 과정과, 라이브러리 파일을 연결해주는 링킹 과정을 통해 최종적으로 메모리에 올라간다. 메모리에 올라가서도 지속적으로 메모리 공간을 차지하는 것이 아니라, 운영체제에 의해 swapping되기도 한다.

- 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조기억 장치로 내보내고 다른 프로세스의 메모리를 불러들일 수 있다.
- 주기억장치(RAM)으로 불러오는 과정을 `swap-in`, 보조 기억장치로 내보내는 과정을 `swap-out` 이라고 한다.
- 큰 디스크 전송 시간이 요구되기 때문에 현재엔 메모리 공간이 부족할 때 swapping이 시작된다.
- swap-out된 프로세스가 다시 메모리에 올라갈 때는 원래 있던 자리로 돌아가지 않을 수 있다.

### 3. 단편화 (Fragmentation)

프로세스들이 차지하는 메모리 사이사이에 사용하지 못할 크기의 작은 빈 공간들이 생기는 것.

- 외부 단편화 : 물리 메모리 사이에서 남는 작은 공간들을 모두 합치면 의미 있는 공간이 되지만, 현재는 작은 부분들로 분산되어 있을 때 발생.
- 내부 단편화 : 프로세스가 사용하는 메모리 공간에 포함된 남은 부분. 요구된 메모리 보다 약간 커서 빈 곳이 쓸모는 없지만 비어있는 상태.
- 압축
  - 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한 쪽으로 몰아 자유공간을 확보하는 방법. 
  - 프로세스들의 재배치가 실행 시간에 동적으로 이루어지는 경우에만 가능하고 작업 효율이 좋지 않다.


## 이수형

### 메모리 관리 배경

각각의 프로세스 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다.
운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

### Swapping

프로세스는 실행 중 임시로 예비 저장장치에 보냈다가 다시 메모리로 돌아올 수 있다.

- 주 기억장치(RAM)으로 불러오는 과정 swap-in
- 보조 기억장치로 내보내는 과정 swap-out
- swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.

### 단편화 (Fragmentation) 

프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나는것

- 외부 단편화
  - 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생한다고 볼 수 있다.
- 내부 단편화
  - 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이 가 존재하고, 이 현상을 내부 단편화라 칭한다. 
- 압축 
  - 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다.

## 윤기재

### 메모리 관리 전략 (메모리 관리 배경)

- 다수의 프로세스를 사용하면서 효율적인 메모리관리의 중요성이 대두되었다.
- 이때, 각 프로세스들의 메모리를 각각공간에 할당하는 역할을 운영체제에서 담당한다.

### 논리 <-> 물리주소 공간

- Cpu 가 생성하는 주소를 논리주소, 메모리가 취급하는 주소를 물리주소라 한다.
- 프로그램 실행 중에는 이와같은 가상주소를 물리주소로 바꿔줘야 하는데, 이 매핑작업은 메모리 관리기(Memory Management Unit)에서 실행된다.

### 스와핑(Swapping)
- 프로세스가 실행되기 위해서는 메모리에있어야 하지만, 다중프로그래밍 환경에서  CPU 할당시간이 끝나면 프로세스의 메모리를 보조 기억장치로 보내고 다른 프로세스의 메모리를 불러 들일 수 있다.

### 단편화(Fragmentation)
- 프로세스들이 메모리에 적재되고 제거되는 일이 반복되면, 프로세스들이 차지하는 메모리 틈사이에 사용하지 못할만큼의 작은 공간들이 늘어나게 되는데, 이것이 단편화 이다. 단편화는 2가지 종류로 나뉜다.
    - 외부 단편화 : 메모리간 남는공간을 모두합치면 적재가능한 메모리양이 나오지만, 각각 분산 되어있어 메모리에 적재하지 못하는 현상
    <img src = "https://user-images.githubusercontent.com/37038119/135719424-19f53880-a80a-4957-8666-005ea66fe120.jpg" width="50%" height="50%">

    - 내부 단편화 : 프로세스사용간 메모리에 남는부분.
    <img src = "https://user-images.githubusercontent.com/37038119/135719427-8a20e08b-8009-44b1-9a91-9b2723011f64.jpg" width="30%" height="30%">



## 우지현

### 메모리 관리 배경

각각의 프로세스는 독립된 메모리 공간을 가지고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 있는 제한이 걸려있다. 단지, **운영체제**만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

### 논리 vs 물리 주소 공간

<img src="https://user-images.githubusercontent.com/37646197/119652673-61644b00-be61-11eb-858b-b7a04801f00e.PNG" width="500" height="300">

CPU가 생성하는 주소를 논리 주소(Logical Address), 메모리가 취급하는 주소를 물리 주소(Physical Address)라 한다. 프로그램 실행 중에는 이와 같은 가상 주소를 물리 주소로 바꿔줘야 하는데, 이 매핑 작업을 메모리 관리기(Memory Management Unit)에서 실행한다.

### Swapping (스와핑)

프로세스가 실행되기 위해서는 메모리에 있어야 하지만, 프로세스는 실행 중에 임시로 예비저장장치(backup store)에 내보내졌다가 실행을 계속하기 위해 다시 메모리로 돌아올 수 있다. 보통 예비저장장치는 속도가 빠른 디스크를 사용한다. 저장장치의 크기는 모든 사용자 메모리 이미지를 저장할 수 있을 정도로 커야하며, 메모리 이미지에 대한 직접 접근이 가능하다. 

![swapping 과정](https://mblogthumb-phinf.pstatic.net/MjAxOTA4MTdfMTQ5/MDAxNTY2MDA5ODc2OTEw.YPE34xyH7dWIO3zZ7RPZ069uGU44qV66o1MVaGZOOmYg.yt4Yrna18d_whYtB16j-5ThGV9fOZmNmOMhNzLhqHfgg.PNG.bisu1532/gfdsfdasda.PNG?type=w800)

- `swap in` : 원하는 프로세스를 주 기억장치(RAM)으로 불러오는 과정
- `swap out` : 현재 메모리에 적재된 프로세스들을 보조 기억장치로 내보내는 과정
- `swap`에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할 때 swapping이 시작된다.
- 상당한 Context-switching time이 발생한다.

### Fragmentation (단편화)

프로세스들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 **단편화**이다. 단편화는 외부 단편화와 내부 단편화로 나뉜다.

![Fragmentation](https://i.stack.imgur.com/dSWgj.gif)

- External Fragmentation(외부 단편화)
  - 메모리 공간 중 사용하지 못하게 되는 일부분
  - 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생한다고 볼 수 있다.
- Internal Fragmentation (내부 단편화)
  - 프로세스가 사용하는 메모리 공간에 포함된 남는 부분
  - 예를 들어 메모리 분할 자유 공간이 10,000B 있고 Process A가 9,9998B 사용하게 되면 2B라는 차이가 존재하고, 이 현상을 내부 단편화라 칭한다.

#### Compaction(압축)

<img src="https://exploringbits.com/wp-content/uploads/2021/01/Compaction-in-operating-system.png?ezimgfmt=ng:webp/ngcb3" width="500" height="300">

외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아 자유공간을 확보하는 방법론이지만 작업효율이 좋지 않다.

## 김민수

### 메모리 관리 배경

- 운영체제와 시스템을 보호하기위해 독립된 메모리 공간을 보장해야한다
- 프로그램이 사용하는 메모리가 점차 커지며 한정된 자원인 메모리를 효율적으로 관리해야한다

### 논리적 vs 물리적 주소

- 논리적 주소
  - 각 프로세스마다 0번지부터 시작
  - cpu는 **<u>논리적 주소</u>**를 바라봄
- 물리적 주소
  - 메모리에 실제 올라가는 위치

### 주소 바인딩 - 프로그램 순서에 따른 바인딩

주소변환은 순전히 하드웨어의 임무, 운영체제는 주소변환에 관여하지 않음

1. **소스코드**

   + 컴파일 타임 바인딩

     컴파일 타임 시에 물리 주소 할당, 현재 os는 사용 안함

2. **실행파일**

   - 로드 타임 바인딩

     프로그램 실행 전에 물리 주소 할당, 컴파일러가 재배치 가능한 코드를 생성한 경우 가능

3. **실행시작**

   - 런타임 바인딩

     실행 중에도 메모리 위치 이동 가능

     cpu가 주소를 참조할 때 마다 바인딩 점검, 하드웨어 지원 필요(base & limit register, **MMU**)

### 스와핑

- 스와핑
  - 프로세스를 일시적으로 메모리에서 백킹 스토어로 내보내는 것
- 백킹 스토어(swap area)
  - 디스크: 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간
- 스왑 인 / 아웃
  - 주로 중기 스케줄러에 의해 아웃시킬 프로세스 선정
  - 우선순위에 따른 관리
  - 효율적인 관리를 위해 런타임 바인딩이 지원돼야함

### 메모리 할당 및 단편화

- 메모리 연속할당

  - 고정 분할 방식(Fixed partition allocation)

    - 물리적 메모리를 n개의 영구적 분할로 나눔

    - 분할 크기가 같은 / 다른 방식 존재

    - 분할당 하나의 프로그램 적재

    - 융통성 없음 - 동시에 메모리에 로드되는 프로그램의 수 고정, 최대 수행가능 프로그램 크기 제한

    - 내부, 외부 조각 발생

      <img src="https://user-images.githubusercontent.com/80962918/135788942-17dd64e4-6c76-4aa3-a893-770d9cf37bd6.png" alt="그림1" width="500" height="500" />

      

  - 가변 분할 방식(Variable partition allocation)

    - 프로그램 크기를 고려해서 할당

    - 분할의 크기, 개수가 동적으로 변함

    - 관리 기법 필요

    - 외부 단편화 발생

      <img src="https://user-images.githubusercontent.com/80962918/135794749-6611012a-a556-42e0-994e-4b46f4d9a2d7.png" alt="그림2" width="500" height="500" />

- 메모리 비연속 할당

  - paging
  - segmentation
  - paging segmentation


