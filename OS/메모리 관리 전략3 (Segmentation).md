# 메모리 관리 전략3 (Segmentation)

## 김현수

Segmentation (세그멘테이션)

- 논리 메모리와 물리 메모리를 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할. 
  > 돼지를 잡아서 보관을 한다고 생각해보자. 페이징의 방법을 사용하면 돼지를 모두 같은 단위로 잘라서 보관을 하는 것이다. 반면에 세그먼테이션은 부위별로 다른 크기로 잘라서 보관하는 것이다.
- 세그먼테이션 기법 하의 논리주소는 세그번트 번호 s와 세그먼트 내 오프셋 d로 이루어진다.
- 주소 변환을 위해 세그먼트 테이블을 사용하며, 세그먼트 테이블에는 세그먼트 번호, 세그먼트 크기(limit), 시작주소(base)를 저장한다.
	- 물리주소는 base[s] + d로 계산된다.
	- CPU에서 limit을 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.
- 내부 단편화 문제를 해소하기 위한 방법이다.
- 메모리 사용 효율이 개선되고 동적 분할을 통한 오버헤드가 감소한다.
- 단점
	- 외부 단편화 문제 해결이 불가하다. (서로 다른 크기의 세그먼트들의 적재와 제거가 반복되면, 자유 공간들이 많은 수의 작은 조각으로 나뉘어 사용하지 못하게 되기 때문)

## 이수형

### 세그멘테이션

프로세스를 물리적인 단위인 페이지 말고 논리적 내용 단위인 세그먼트로 자를 수 있는 방법<br/>
페이징은 모두 같은 단위로 쭉 자른다면 세그멘테이션은 집합별로 다른 크기로 자른다는것<br/>
하지만 세그먼테이션의 방법으로 자르게 되면 코드 영역은 코드 영역으로 잘리게 되고 중요한 세그먼트, 중요하지 않은 세그먼트를 논리적인 내용 측면으로 자를 수 있다.<br/>
그렇게 되면 보호와 공유의 기능을 수행하기 쉬워지는 것이다. 내용적인 측면으로 다 나누어 졌기 때문이다.

단점

크기가 다른 각 세그먼트를 메모리에 두려면 동적 메모리 할당을 해야 한다. <br/>
외부 단편화가 발생할 수 있다. 외부 단편화는 메모리 낭비를 매우 크게 발생시킨다.<br/>

둘다 사용한다면?

프로세스를 처음에 세그먼트 단위로 자른다 의미 있는 단위로 나누게 되면 보호와 공유를 하는 측면에 이점을 가질 수 있게 된다. <br/>
그러나 외부단편화가 발생할 수 있기에 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 취한다. <br/>
그래서 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화가 발생하지 않는다. <br/>
하지만 이와 같은 경우에는 테이블을 두 가지를 모두 거쳐야 하므로 속도 면에서 조금 떨어질 수 있다.

