# 메모리 관리 전략3 (Segmentation)

## 김현수

Segmentation (세그멘테이션)

- 논리 메모리와 물리 메모리를 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할. 
  
  > 돼지를 잡아서 보관을 한다고 생각해보자. 페이징의 방법을 사용하면 돼지를 모두 같은 단위로 잘라서 보관을 하는 것이다. 반면에 세그먼테이션은 부위별로 다른 크기로 잘라서 보관하는 것이다.
- 세그먼테이션 기법 하의 논리주소는 세그번트 번호 s와 세그먼트 내 오프셋 d로 이루어진다.
- 주소 변환을 위해 세그먼트 테이블을 사용하며, 세그먼트 테이블에는 세그먼트 번호, 세그먼트 크기(limit), 시작주소(base)를 저장한다.
	- 물리주소는 base[s] + d로 계산된다.
	- CPU에서 limit을 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.
- 내부 단편화 문제를 해소하기 위한 방법이다.
- 메모리 사용 효율이 개선되고 동적 분할을 통한 오버헤드가 감소한다.
- 단점
	- 외부 단편화 문제 해결이 불가하다. (서로 다른 크기의 세그먼트들의 적재와 제거가 반복되면, 자유 공간들이 많은 수의 작은 조각으로 나뉘어 사용하지 못하게 되기 때문)

## 이수형

### 세그멘테이션

프로세스를 물리적인 단위인 페이지 말고 논리적 내용 단위인 세그먼트로 자를 수 있는 방법<br/>
페이징은 모두 같은 단위로 쭉 자른다면 세그멘테이션은 집합별로 다른 크기로 자른다는것<br/>
세그먼테이션의 방법으로 자르게 되면 코드 영역은 코드 영역으로 잘리게 되고 중요한, 중요하지 않은 세그먼트를 논리적인 내용 측면으로 자를 수 있다.<br/>
보호와 공유의 기능을 수행하기 쉬워진다

단점

크기가 다른 각 세그먼트를 메모리에 두려면 동적 메모리 할당을 해야 한다. <br/>
외부 단편화가 발생할 수 있다. 외부 단편화는 메모리 낭비를 매우 크게 발생시킨다.<br/>

둘다 사용한다면?

프로세스를 처음에 세그먼트 단위로 자른다 의미 있는 단위로 나누게 되면 보호와 공유를 하는 측면에 이점을 가질 수 있게 된다. <br/>
그러나 외부단편화가 발생할 수 있기에 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 취한다. <br/>
그래서 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 때문에 외부 단편화가 발생하지 않는다. <br/>
하지만 이와 같은 경우에는 테이블을 두 가지를 모두 거쳐야 하므로 속도 면에서 조금 떨어질 수 있다.

## 우지현

### Segmentation (세그멘테이션)

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(segment)로 분할하고 메모리에 배치하는 것을 말하며, 각 세그먼트의 크기는 일정하지 않다. 프로세스를 Code + Data + Stack 영역으로 나누는 것 역시 세그멘케이션의 모습이다. 물론 Code, Data, Stack 각각 내부에서 더 작은 세그먼트로 나눌 수도 있다.

세그먼트를 메모리에 할당하는 것은 페이지를 할당하는 것과 동일하지만 테이블은 조금 다르다. 세그멘테이션을 위한 테이블은 세그먼트 테이블이라고 하며, 세그먼트 번호와 시작 주소, 세그먼트 크기를 엔트리로 갖는다. 세그먼트에서 주소 변환 역시 페이징과 유사하다. 한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에 테이블에 limit 정보가 주어지며 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.

![Segmentation](https://user-images.githubusercontent.com/34755287/57119448-47043400-6da5-11e9-95da-91cb808de992.png)

위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습으로 페이징 주소변환과 동일하게 d(변위 : 변하지 않는 값)는 논리 주소와 물리 주소가 동일하다. 물리 주소 a는 base[s] + d로 계산된다.

- 논리 주소 (2, 100) -> 물리 주소 4400번지
- 논리 주소 (1, 500) -> limit이 400이므로 인터럽트로 인해 프로세스 강제 종료 (범위 벗어남)

#### 단점

서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다. (외부 단편화)

