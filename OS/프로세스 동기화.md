# 프로세스 동기화

## 우지현

### Process Synchronization (프로세스 동기화)

협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것.

프로세스가 서로 협력하며 공유 자원을 사용하는 상황에서, 경쟁 조건이 발생하면 공유 자원을 신뢰할 수 없게 만들 수 있다. 이를 방지하기 위해 프로세스들이 공유 자원을 사용할 때 특별한 규칙을 만드는 것이 프로세스 동기화이다.

### Race Condition (경쟁 조건)

공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태를 말한다. 동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다.

#### Race Condition이 발생하는 경우

1. 커널 작업을 수행하는 중에 인터럽트 발생
   - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
   - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.
2. 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때
   - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 (프로세스2가 작업에 반영되지 않는다.)
   - 해결법 : 프로세스가 커널 모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 한다.
3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때
   - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
   - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

### Critical Section (임계 구역)

여러 프로세스가 데이터를 공유하면서 수행될 때, 각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분을 뜻한다. 공유 자원의 독점을 보장해주는 역할을 수행한다.

#### Critical Section Problem (임계 구역 문제)

프로세스들이 Critical Section을 함께 사용할 수 있는 프로토콜을 설계하는 것이다.

#### Requirements (해결을 위한 기본 조건)

- Mutual Exclusion (상호 배제)

  어떤 프로세스 (또는 스레드)가 임계 구역에서 작업 중일 때, 다른 프로세스는 임계 구역에 접근할 수 없다.

- Progress (진행)

  임계 구역에서 작업 중인 프로세스가 없다면, 임계 구역으로 진입하려는 프로세스 중 하나를 적절히 선택하여 임계 구역에 진입할 수 있게 해야 한다.

- Bounded Waiting (유한 대기)

  다른 프로세스의 기아(Starvation)를 방지하기 위해, 임계 구역에 한 번 접근했던 프로세스는 다시 임계 구역에 들어갈 때 제한을 두어야 한다.

#### 해결책

소프트웨어적인 방법

- Peterson's Algorithm (피터슨의 알고리즘) : Peterson's Solution(피터슨의 해결안)이라고도 하며, 2개의 프로세스만 있을 때 사용 가능
- Dekker's Algorithm (데커의 알고리즘) : 피터슨의 알고리즘과 비슷하며, 2개의 프로세스만 있을 때 사용 가능
- Lamport's Bakery Algorithm (램포트의 빵집 알고리즘) : 2개 이상의 프로세스에서 사용 가능

하드웨어 활용 방법

Lock

- 하드웨어 기반의 해결책으로써, 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section에 진입하는 프로세스는 Lock을 획득하고 Critical Section을 빠져나올 때, Lock을 방출함으로써 동시에 접근이 되지 않도록 한다.
- 한계 : 다중처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.

Semaphores (세마포)

- 소프트웨어상에서 Critical Section 문제를 해결하기 위한 동기화 도구

- 종류

  - Counting Semaphore (카운팅 세마포)

    가용한 개수를 가진 자원에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 자원의 개수로 초기화된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다.

  - Binary Semaphore (이진 세마포)

    Mutex(뮤텍스)라고도 부르며, 상호 배제(Mutual Exclusion)의 머릿글자를 따서 만들어졌다. 이름 그대로 0과 1 사이의 값만 가능하며, 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다.

- 단점

  - Busy Waiting (바쁜 대기)

    Spin lock이라고 불리는 Semaphore 초기 버전에서 Critical Section에 진입해야 하는 프로세스는 진입 코드를 계속 반복 실행해야 하며, CPU 시간을 낭비했었다. 이를 Busy Waiting이라고 부르며 특수한 상황이 아니면 비효율적이다. 일반적으로는 Semaphore에서 Critical Section에 진입을 시도했지만 실패한 프로세스에 대해 Block시킨 뒤, Critical Section에 자리가 날 때 다시 깨우는 방식을 사용한다. 이 경우 Busy Waiting으로 인한 시간 낭비 문제가 해결된다.

- Deadlock (교착 상태)

  세마포가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되어야만 빠져나올 수 있는 상황을 지칭한다.

Monitor (모니터)

- 고급 언어의 설계 구조물로서, 개발자의 코드를 상호 배제 하게끔 만든 추상화된 데이터 형태이다.

- 공유자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리한다.

  (세마포어는 직접 키 해제와 공유자원 접근 처리가 필요하다.)


### 이수형

### 프로세스 동기화

프로세스가 cpu를 차지하기 위해 경쟁하며 각 프로세스는 경우에 따라 다른 프로세스와 데이터를 공유할 수 있음.
각 프로세스가 사용하는 공유 데이터에 대한 무결성 보장을 위해 해당 데이터에 대한 동기화 처리가 필요함

### 경쟁 조건

두 개 이상의 프로세스가 공통 자원을 읽거나 쓸 때 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어 졌는지에 따라 그 실행 결과가 달라지는 상황

- 커널 수행중 인터럽트 발생
- 해결 : 커널 모드에서 작업을 하는 도중에 인터럽트가 걸려도 무시하고 작업이 끝나면 인터럽터를 처리
- 프로세스가 System Call 하여 커널 모드로 수행중인데 context switch가 일어나는경우
- 해결 : 어떤 프로세스가 커널모드에 있는경우 CPU시간이 끝나도 CPU제어권을 빼앗지않고 작업이 끝나고 CPU제어권을 뺏음
- 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근
- 해결 : 데이터에 대한 접근을 제한해야함, LOCK/UNLOCK을 이용하거나 매 순간 하나의 CPU만 커널에 접근가능하도록 할수도 있음

### 임계영역

n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드
하나의 프로세스가 임계영역에 있을 때 다른 모든 프로세스는 임계영역에 들어갈 수 없어야 함

- 임계영역 문제를 해결하기 위한 조건
1. 상호 배제 : 프로세스A가 임계영역에 들어가 있으면 다른 모든 프로세스들은 임계영역에 들어가면 안됨
2. 진행 : 아무도 임계영역에 있지 않은 상태에서 임계영역에 들어가고자 하는 프로세스가 있으면 임계영역에 들어가게 해주어여 함
3. 유한 대기 : 프로세스가 임계영역에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 임계영역에 들어가는 횟수에 한계가 있어야 함(starvation 방지)

### 해결책

1. 소프트웨어적 방법( ex. 피터슨 알고리즘)

```java
do{
flag[i]=true;// i 가 사용하고싶어함
trun =j;// i가 쓰고싶다고 설언해주고 j차례로 돌려서 혹시 다른프로세스가 쓰고싶나 확인
while(flag[j]&&trun==j);//자기 턴일때까지 spinlock에 머물러야함 여기서 cpu낭비를함
//임계영역 사용
flag[i]=false;//사용이 끝나면 해제
//나옴
}while(true)
```

1. 하드웨어적 방법 (LOCK)
    - 사용할때 LCOK을 걸고 사용이 끝난 뒤에 LOCK을 해제
2. 세마포어
    - 이진 세마포어 : Mutex LOCK처럼 0이면 락 1이면 unlock
    - 카운팅 세마포어 : n개의 자원을 locking 하나의 자원할당시 n-1, 두개는 n-2 이런식으로 0까지 할당가능
    - 둘이상의 프로세스가 무한정 대기하는 Dead Lock에 걸릴 수 있음 이때는 시간을 우선순위로 두어 해결
