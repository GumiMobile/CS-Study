## 가상 메모리 (페이지 교체 알고리즘)

## 이수형

### 페이지 교체 알고리즘

가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 두지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음<br/>
이때 상황에 맞는 페이지 교체를 진행하기 위해 알고리즘이 존재함.<br/>
일반적으로는 페이지 부재율이 가장 낮은 것을 선정 하는 알고리즘을 사용

1. FIFO(First In First Out)

   가장 먼저 메모리에 올라온 페이지부터 먼저 내보냄

   특히 초기화 단계에서 적절한 방법

   단점
   - 가장 오래 있었던 페이지는 앞으로 계속 사용될 가능성이 있음.

   - 즉 페이지 부재율이 높아질수 있어 효율이 많이 떨어질 수 있음

   - Belady의 모순 발생

   > Belady 의 모순 : 많은 프레임을 할당해 주었는데도 불구하고 반대로 페이지 부재율이 더 증가하는 현상

2. OPT(Optimal Page Replacement)

   가장 사용하지 않을 페이지를 먼저 내보냄

   단점

   - 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 프로그램을 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드 발생

   - 실질적으로 이 페이지가 잘 사용될지 말지에 대한 판단이 어려워서 사용하기 어려운 알고리즘


3. LRU(Least-Recently-Used)

   가장 오랫동안 사용되지 않은 페이지를 먼저 내보냄

   실제로 최근에 사용하지 않은 페이지는 앞으로 사용하지 않을 확률이 높다는 것에서 착안<br/>
   OPT는 미래를 예측해야하지만 LRU는 과거를 보고 판단<br/>
   시간의 지역성에 기반

   단점

   - 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야함. 큰 오버헤드가 발생

   - 경험적 판단이 맞지 않는 상황도 존재

4. LFU(Least Frequently Used)

   가장 오랫동안 참조되지 않은 페이지를 먼저 내보냄

   단점
   - 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높음

   - 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 횟수를 기록해야함. 큰 오버헤드가 발생


5. NUR(Not Used Recently)

   참조 여부와 수정여부에 따라 우선순위를 결정해 적절한 페이지를 교체

   LRU와 유사하면서 실제로 자주 쓰이는 방법

6. second chance

   FIFO기법과 LFU에 따라 우선순위를 결정해 적절한 페이지를 교체

   > 이를 원형 큐를 이용하면 Clock 기법

## 김민수

### Optimal Algorithm

이론적으로만 가능한 최대 성능의 알고리즘이다. 미래에 사용되는 page를 미리 알고 있다고 가정할 때 구현 가능하다. 가장 먼 미래에 참조되는 페이지를 교체한다.

<img src="https://user-images.githubusercontent.com/80962918/136782651-cad45252-c7af-40e2-9538-6543784ff949.png" style width = "700"/>

위 예시는 4프레임에서 일어나는 이상적인 페이지 교체 알고리즘이다. 맨 위의 숫자는 사용할 페이지이다. 7번째 그림에서 5번 페이지를 메모리에 올려야 한다. 이때, 기존 프레임에 올라와 있는 1, 2, 3, 4 페이지 중 가장 먼 미래에 참조되는 페이지는 4번 페이지이므로 5번 페이지는 4번째 프레임에 들어간다. 위 예시에서는 6번의 page fault가 발생한다.

이 알고리즘은 다른 알고리즘의 성능에 대한 upper bound로 사용된다.

### FIFO (First In First Out)

선입 선출 알고리즘으로 먼저 들어온 순서대로 교체된다.

![그림2](https://user-images.githubusercontent.com/80962918/136784345-4d0a0241-673d-46f4-9000-f47c4d163f2d.png)

프레임이 많다고 무조건 page fault가 적게 일어나지 않는다. 이런 현상을 FIFO Anomaly (Belady's Anomaly)라 한다.

### LRU (Least Recently Used)

과거 기록을 이용하여 가장 오래 전에 참조된 페이지를 교체한다.

<img src="https://user-images.githubusercontent.com/80962918/136785481-efa234cc-6bde-41e8-a7c4-4841f28eadb2.png" style width="700"/>

### LFU (Least Frequently Used)

참조 횟수가 가장 적은 페이지를 교체한다. 최저 참조 횟수가 같은 페이지가 존재할 경우 여러 페이지 중 임의로 선정하거나, 가장 오래전에 참조된 페이지를 선정한다.

LRU처럼 직전 참조 시점만 보는 것이 아니라 긴 시간동안 페이지 참조 기록을 하기 때문에 페이지의 인기도를 더 정확히 반영할 수 있다. 하지만 참조 시점의 최근성을 반영하지 못하고 LRU보다 구현이 복잡하다.

#### 실제 Paging System에서 LRU, LFU 알고리즘을 사용할 수 있는가?

메모리에 이미 존재하는 페이지의 경우 운영체제는 메모리 주소 변환에 관여를 하지 않는다. 이는 실제 메모리를 참조하는 경우 순수하게 하드웨어를 통해 이뤄진다는 뜻이다. 따라서 운영체제는 어떤 페이지가 가장 오래전에 참조되었는지, 혹은 가장 적게 참조되었는지 알지 못한다. 따라서 Clock Algorithm을 사용한다. LRU, LFU는 버퍼 캐싱, 웹 캐싱 등의 분야에서 사용된다.

### Clock Algorithm

Clock Algorithm은 LRU의 근사 알고리즘이다. Second chance algoritm이라고도 한다. cpu가 해당 페이지를 참조할때 하드웨어는 Reference bit을 1로 바꿔주고, 운영체제는 page fault가 발생할 경우, Reference bit 참조하여 교체 페이지를 선정한다.

<img src="https://user-images.githubusercontent.com/80962918/136788889-1c427f6e-f9be-419b-8e94-ef75bf593c0b.png" style width="700"/>

Reference bit이 1일 경우 운영체제는 0으로 바꾸고 다음 페이지를 탐색한다. 만약 Reference bit이 0일 경우 해당 페이지를 교체한다.

Reference bit이 0인 의미는 시계 바늘이 한바퀴 돌 동안, 한번도 참조되지 않았다는 뜻이고, 이는 한 사이클 동안 가장 오래전에 참조되어서 교체 대상으로 선정되는 것이다.




## 윤기재

### 페이지 교체 알고리즘
가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다.
하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있다.

### FIFO
메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘

![fifo](https://user-images.githubusercontent.com/37038119/136801432-909b1e74-4be0-44bf-b63d-0d90eb90bfe2.png)<br>

#### 단점
- 오래전에 적재되어 반복적으로 사용되는 페이지가 교체될수있음  
<br>

### LRU
최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘

![LRU](https://user-images.githubusercontent.com/37038119/136801510-207696d2-e74e-46bb-b3e4-a595d039e6f8.png) <br>

##### 단점
- 막대한 오버헤드 발생
<br>

### LFU
참조된 횟수가 가장 적은 페이지 교체

##### 단점
- 가장 최근에 옮겨진 페이지가 교체될 가능성이 높음
- 초기에 사용된후 더이상 사용되지 않는 체이지는 교체가능성 낮음
<br>

### NUR
- LRU와 비슷, 최근에 사용하지 않은 페이지 교체
- LRU에서 나타나는 오버헤드를 줄일 수 있다.
- 최근의 사용여부를 확인 하기 위해 각페이지마다 두개의 비트 사용

## 우지현

### 페이지 교체

`요구 페이징`에서 언급된대로 프로그램 실행 시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 `page fault (페이지 부재)`가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다. (또는, 운영체제가 프로세스를 강제로 종료하는 방법이 있다.)

#### 기본적인 방법

물리 메모리가 모두 사용중인 상황에서의 메모리 교체 흐름이다.

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다.
   1. `페이지 교체 알고리즘`을 통해 희생될(victim) 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

### 페이지 교체 알고리즘

#### FIFO 페이지 교체

![FIFO](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FVQCGK%2FbtquJuqRkyS%2FLb3NgwHkBve08YhZpLkq31%2Fimg.png)

- 가장 간단한 페이지 교체 알고리즘으로 FIFO(first-in-first-out)의 흐름을 가진다.
- 즉, 먼저 물리 메모리에 들어온 페이지 순서대로 페이지 교체 시점에 먼저 나가게 된다.
- 장점
  - 이해하기 쉽고, 프로그래밍하기도 쉽다.
- 단점
  - 오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다. (초기 변수 등)
  - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래할 수 있다.
  - `Belady의 모순` : 페이지를 저장할 수 있는 페이지의 프레임 개수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.

#### 최적 페이지 교체 (Optimal Page Replacement)

![최적](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FSvRs7%2FbtquHbeJLQX%2FWXmK7xdGUbIxl43t0JG6Qk%2Fimg.png)

- `Belady의 모순`을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘보다 낮은 페이지 부재율을 보이며 `Belady의 모순`이 발생하지 않는다.
- 이 알고리즘의 핵심은 `앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체`하는 것이다.
- 주로 비교 연구 목적을 위해 사용한다.
- 장점
  - 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.
- 단점
  - 구현의 어려움이 있다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

#### LRU 페이지 교체 (LRU Page Replacement)

![LRU](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FnCgc3%2FbtquGW9VUrm%2FxTKnVKPOVQuSXmAuRehSw1%2Fimg.png)

- `LRU` : Least Recently Used
- 최적 알고리즘의 근사 알고리즘
- 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
- 대체적으로 `FIFO 알고리즘`보다 우수하고 `OPT 알고리즘`보다는 그렇지 못한 모습을 보인다.

#### LFU 페이지 교체 (LFU Page Replacement)

- `LFU` : Least Frequently Used
- 참조 횟수가 가장 적은 페이지를 교체하는 방법
- 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정에서 만들어진 알고리즘
- 어떤 프로세스가 특정 페이지를 집중적으로 사용하다 다른 기능을 사용하게 되면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생할 수 있다.
- 최적 (OPT) 페이지 교체를 제대로 근사하지 못하기 때문에 잘 쓰이지 않는다.

#### MFU 페이지 교체 (MFU Page Replacement)

- `MFU` : Most Frequently Used
- 참조 횟수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반한다.
- 최적(OPT) 페이지 교체를 제대로 근사하지 못하지 때문에, 잘 쓰이지 않는다.

## 김현수

### 페이지 교체 알고리즘

1. FIFO (First In First Out)
- 가장 먼저 들어온 페이지를 내린다.
- 물리 메모리에 페이지를 추가할 공간이 부족하면, 제일 먼저 들어온 페이지의 위치에 새로운 페이지를 올려 교체한다.

2. OPT (OPTimal Replacement Algorithm, 최적 페이지 교체 알고리즘)
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다.
- 일반 OS에서는 구현 불가

3. LRU (Least Recently Used)
- 가장 오래 전에 사용된 페이지를 교체
- OPT 교체 알고리즘은 구현이 불가하므로, 대신 가장 사용한 지 오래된 페이지를 새로운 페이지와 교체하는 방식으로 구현
- 가장 많이 쓰이는 페이지 교체 알고리즘

4. LFU (Least Frequently Used)
- 가장 적게 사용된 페이지를 새로운 페이지와 교체한다.

5. NUR (Not Used Recently)
- LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
- 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R, M)
	- (0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체
	
6. 스레싱(Thrashing)
- 반복적으로 페이지 폴트가 발생해서, 과도하게 페이지 교체 작업이 일어나, 실제로는 아무 일도 하지 못하는 상황
- 프로그램은 수행하지 못한 채 페이지 폴트와 페이지 스왑만 반복적으로 수행

## 이유진
### 페이지 교체 알고리즘
- 페이지 교체 : 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내 빈 공간을 확보하는 것
- 교체 알고리즘 : 페이지 부재율을 최소화하는 것

#### 최적 알고리즘
- 가장 먼 미래에 참조될 페이지를 쫓아내는 것
- 미래의 페이지가 참조될 순서를 미리 알고있어야 하므로, 실제 시스템에서 사용할 수 있는 알고리즘은 아님
- 오프라인 알고리즘이라고 부름
- 다만, 다른 알고리즘의 성능에 대한 상항선을 제공함

#### 선입선출 알고리즘
- 물리적 메모리에 가장 먼저 올라온 페이지를 우선적으로 내쫓음
- 단점으로 이상현상이 발생함

#### LRU 알고리즘
- 가장 오래전에 참조된 페이지를 쫓아낸다.

#### LFU 알고리즘
- 과거에 참조 횟수가 가장 적었던 페이지를 쫓아낸다.
- 시간에 따른 페이지 참조의 변화를 반영하지 못하고, LRU보다 구현이 복잡하다.

#### 클럭 알고리즘
- LRU와 LFU는 페이지 참조 시각과 횟수를 유지하고 비교하므로 알고리즘 운영에 시간적인 오버헤드가 발생한다.
- 오랫동안 참조되지 않은 페이지 중 하나를 교체한다.
- 하드웨어적인 자원으로 동작하므로, 페이지의 관리가 빠르고 효율적이다.
- 대부분 시스템에서 채택한 알고리즘
- `참조비트`를 순차적으로 조사한다. 참조비트가 1인 페이지는 0으로 바꾸고, 참조비트가 0인 페이지는 교체한다. 즉, 시곗바늘이 한 바퀴 도는 동안 다시 참조되지 않은 페이지를 교체한다.
