## 가상 메모리 (페이지 교체 알고리즘)

## 이수형

### 페이지 교체 알고리즘

가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 두지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음<br/>
이때 상황에 맞는 페이지 교체를 진행하기 위해 알고리즘이 존재함.<br/>
일반적으로는 페이지 부재율이 가장 낮은 것을 선정 하는 알고리즘을 사용

1. FIFO(First In First Out)

   가장 먼저 메모리에 올라온 페이지부터 먼저 내보냄

   특히 초기화 단계에서 적절한 방법

   단점
   - 가장 오래 있었던 페이지는 앞으로 계속 사용될 가능성이 있음.

   - 즉 페이지 부재율이 높아질수 있어 효율이 많이 떨어질 수 있음

   - Belady의 모순 발생

   > Belady 의 모순 : 많은 프레임을 할당해 주었는데도 불구하고 반대로 페이지 부재율이 더 증가하는 현상

2. OPT(Optimal Page Replacement)

   가장 사용하지 않을 페이지를 먼저 내보냄

   단점

   - 참조될 가능성이 많음에도 불구하고 횟수에 의한 방법이므로 최근에 사용된 프로그램을 교체시킬 가능성이 있고, 해당 횟수를 증가시키므로 오버헤드 발생

   - 실질적으로 이 페이지가 잘 사용될지 말지에 대한 판단이 어려워서 사용하기 어려운 알고리즘


3. LRU(Least-Recently-Used)

   가장 오랫동안 사용되지 않은 페이지를 먼저 내보냄

   실제로 최근에 사용하지 않은 페이지는 앞으로 사용하지 않을 확률이 높다는 것에서 착안<br/>
   OPT는 미래를 예측해야하지만 LRU는 과거를 보고 판단<br/>
   시간의 지역성에 기반

   단점

   - 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 시간을 기록해야함. 큰 오버헤드가 발생

   - 경험적 판단이 맞지 않는 상황도 존재

4. LFU(Least Frequently Used)

   가장 오랫동안 참조되지 않은 페이지를 먼저 내보냄

   단점
   - 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높음

   - 프로세스가 주기억장치에 접근할 때마다 참조된 페이지에 대한 횟수를 기록해야함. 큰 오버헤드가 발생


5. NUR(Not Used Recently)

   참조 여부와 수정여부에 따라 우선순위를 결정해 적절한 페이지를 교체

   LRU와 유사하면서 실제로 자주 쓰이는 방법

6. second chance

   FIFO기법과 LFU에 따라 우선순위를 결정해 적절한 페이지를 교체

   > 이를 원형 큐를 이용하면 Clock 기법

## 김민수

### Optimal Algorithm

이론적으로만 가능한 최대 성능의 알고리즘이다. 미래에 사용되는 page를 미리 알고 있다고 가정할 때 구현 가능하다. 가장 먼 미래에 참조되는 페이지를 교체한다.

<img src="https://user-images.githubusercontent.com/80962918/136782651-cad45252-c7af-40e2-9538-6543784ff949.png" style width = "700"/>

위 예시는 4프레임에서 일어나는 이상적인 페이지 교체 알고리즘이다. 맨 위의 숫자는 사용할 페이지이다. 7번째 그림에서 5번 페이지를 메모리에 올려야 한다. 이때, 기존 프레임에 올라와 있는 1, 2, 3, 4 페이지 중 가장 먼 미래에 참조되는 페이지는 4번 페이지이므로 5번 페이지는 4번째 프레임에 들어간다. 위 예시에서는 6번의 page fault가 발생한다.

이 알고리즘은 다른 알고리즘의 성능에 대한 upper bound로 사용된다.

### FIFO (First In First Out)

선입 선출 알고리즘으로 먼저 들어온 순서대로 교체된다.

![그림2](https://user-images.githubusercontent.com/80962918/136784345-4d0a0241-673d-46f4-9000-f47c4d163f2d.png)

프레임이 많다고 무조건 page fault가 적게 일어나지 않는다. 이런 현상을 FIFO Anomaly (Belady's Anomaly)라 한다.

### LRU (Least Recently Used)

과거 기록을 이용하여 가장 오래 전에 참조된 페이지를 교체한다.

<img src="https://user-images.githubusercontent.com/80962918/136785481-efa234cc-6bde-41e8-a7c4-4841f28eadb2.png" style width="700"/>

### LFU (Least Frequently Used)

참조 횟수가 가장 적은 페이지를 교체한다. 최저 참조 횟수가 같은 페이지가 존재할 경우 여러 페이지 중 임의로 선정하거나, 가장 오래전에 참조된 페이지를 선정한다.

LRU처럼 직전 참조 시점만 보는 것이 아니라 긴 시간동안 페이지 참조 기록을 하기 때문에 페이지의 인기도를 더 정확히 반영할 수 있다. 하지만 참조 시점의 최근성을 반영하지 못하고 LRU보다 구현이 복잡하다.

#### 실제 Paging System에서 LRU, LFU 알고리즘을 사용할 수 있는가?

메모리에 이미 존재하는 페이지의 경우 운영체제는 메모리 주소 변환에 관여를 하지 않는다. 이는 실제 메모리를 참조하는 경우 순수하게 하드웨어를 통해 이뤄진다는 뜻이다. 따라서 운영체제는 어떤 페이지가 가장 오래전에 참조되었는지, 혹은 가장 적게 참조되었는지 알지 못한다. 따라서 Clock Algorithm을 사용한다. LRU, LFU는 버퍼 캐싱, 웹 캐싱 등의 분야에서 사용된다.

### Clock Algorithm

Clock Algorithm은 LRU의 근사 알고리즘이다. Second chance algoritm이라고도 한다. cpu가 해당 페이지를 참조할때 하드웨어는 Reference bit을 1로 바꿔주고, 운영체제는 page fault가 발생할 경우, Reference bit 참조하여 교체 페이지를 선정한다.

<img src="https://user-images.githubusercontent.com/80962918/136788889-1c427f6e-f9be-419b-8e94-ef75bf593c0b.png" style width="700"/>

Reference bit이 1일 경우 운영체제는 0으로 바꾸고 다음 페이지를 탐색한다. 만약 Reference bit이 0일 경우 해당 페이지를 교체한다.

Reference bit이 0인 의미는 시계 바늘이 한바퀴 돌 동안, 한번도 참조되지 않았다는 뜻이고, 이는 한 사이클 동안 가장 오래전에 참조되어서 교체 대상으로 선정되는 것이다.




## 윤기재

### 페이지 교체 알고리즘
가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다.
하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있다.

### FIFO
메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘

![fifo](https://user-images.githubusercontent.com/37038119/136801432-909b1e74-4be0-44bf-b63d-0d90eb90bfe2.png)<br>

#### 단점
- 오래전에 적재되어 반복적으로 사용되는 페이지가 교체될수있음  
<br>

### LRU
최근에 사용하지 않은 페이지를 가장 먼저 내려보내는 알고리즘

![LRU](https://user-images.githubusercontent.com/37038119/136801510-207696d2-e74e-46bb-b3e4-a595d039e6f8.png) <br>

##### 단점
- 막대한 오버헤드 발생
<br>

### LFU
참조된 횟수가 가장 적은 페이지 교체

##### 단점
- 가장 최근에 옮겨진 페이지가 교체될 가능성이 높음
- 초기에 사용된후 더이상 사용되지 않는 체이지는 교체가능성 낮음
<br>

### NUR
- LRU와 비슷, 최근에 사용하지 않은 페이지 교체
- LRU에서 나타나는 오버헤드를 줄일 수 있다.
- 최근의 사용여부를 확인 하기 위해 각페이지마다 두개의 비트 사용
