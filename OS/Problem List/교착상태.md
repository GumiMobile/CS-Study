# 교착상태

## 김민수

### 교착상태란? (Dead Lock)

두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 아무 것도 완료되니 못하는 상태를 가르킨다.

### 교착상태의 발생조건

교착상태가 발생할 조건은 아래 4가지 조건을 모두 만족해야 한다. 반대로 말하면 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않는다.

- 상호 배제
  - 한 번에 프로세스 하나만 해당 자원을 독점적으로 사용한다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
- 점유 대기
  - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
- 비선점
  - 이미 할당된 자원을 강제로 빼앗을 수 없다.
- 순환 대기
  - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

### 교착상태 처리방법

- 교착상태를 미리 예방

  - 자원 할당 시 4가지 조건 중 어느 하나가 만족되지 않도록 한다.

    1. 상호 배제 : 공유해서는 안되는 자원의 경우 상호배제를 피할 수 없다. 보통 나머지 조건들을 통해 예방한다.

    2. 점유 대기: 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다.

       e.g 1. 프로세스 시작 시 필요한 모든 자원을 할당 받는다.

       e.g 2. 자원이 필요할 경우 보유 자원을 반납하고 다시 요청한다.

    3. 비선점: 프로세스가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점된다.(보유 자원을 뺏긴다. 보유 자원은 save, restore가 쉬워야 한다.)

    4. 순환 대기: 모든 자원에 할당 순서를 정하여 정해진 순서대로만 자원 할당

       e.g 순서가 3인 자원 Ri를 보유한 프로세스가 순서가 1인 자원 Rj를 할당 받기 위해서는 우선 Ri를 반납해야 한다.

  - 문제점: 자원 이용률 저하, 시스템 처리율 감소, 기아 문제

- 교착상태 발생을 회피

  - 자원 요청에 대한 부가적인 정보를 이용해서 교착상태의 가능성이 없는 경우에만 자원을 할당한다.
  - 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원을 할당한다.
  - [은행원 알고리즘] (#은행원-알고리즘)

- 교착상태 탐지 및 회복

  - 교착상태 발생은 허용하나, 그에 대한 탐지 루틴을 두어 교착상태를 회복시킨다.
  - 교착상태 프로세스 전부 끄거나, 교착상태가 풀릴 때까지 프로세스를 하나씩 끈다.

- 교착상태 무시

  - 교착상태를 시스템이 책임지지 않는다.
  - UNIX를 포함한 대부분의 OS가 채택

#### 은행원 알고리즘

- 가정
  - 모든 프로세스는 자원의 최대 사용량을 미리 명시
  - 프로세스가 요청 자원을 모두 할당받은 경우 유한 시간 안에 이들 자원을 다시 반납한다.
- 방법
  - 자원 요청시 safe 상태를 유지할 경우에만 자원 할당
  - 총 요청 자원의 수가 가용 자원의 수 보다 적은 프로세스를 선택, 없으면 unsafe
  - 선택한 프로세스에게 자원 할당
  - 프로세스가 종료되면 모든 자원을 반납
  - 모든 프로세스가 종료될 때까지 과정 반복

<img src="https://user-images.githubusercontent.com/80962918/137317394-38aa383f-cded-40ea-96ab-40c7d05f15ee.png" style width="600"/>

- step 1

  가용자원: 3 3 2

  P0: 빨간색칸의 필요한 자원 수가 가용 자원보다 많아 할당 불가

  P1: 필요 자원 수가 가용 자원보다 적으므로 할당 가능

  P2: 빨간색칸의 필요한 자원 수가 가용 자원보다 많아 할당 불가

  P3: 필요 자원 수가 가용 자원보다 적으므로 할당 가능

  P4: 빨간색칸의 필요한 자원 수가 가용 자원보다 많아 할당 불가

  결과: [P1] (P1 작업 후 자원 모두 반납)

- step 2

  가용자원: 5 3 2

  P0: 불가

  P2: 불가

  P3: 가능

  P4: 가능

  step 1에서 P3도 가능했으므로

  결과: [P1, P3] (P3 작업 후 자원 모두 반납)

- step 3

  가용자원: 7 4 3

  P0: 가능

  P2: 가능

  P4: 가능

  step 2에서 P4도 가능했으므로

  결과: [P1, P3, P4]

- step ~

  결과: [P1, P3, P4, P2, P0]이 존재하므로 시스템 safe state