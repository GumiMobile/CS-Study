# 교착상태

## 김민수

### 교착상태란? (Dead Lock)

두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 아무 것도 완료되니 못하는 상태를 가르킨다.

### 교착상태의 발생조건

교착상태가 발생할 조건은 아래 4가지 조건을 모두 만족해야 한다. 반대로 말하면 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않는다.

- 상호 배제
  - 한 번에 프로세스 하나만 해당 자원을 독점적으로 사용한다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
- 점유 대기
  - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
- 비선점
  - 이미 할당된 자원을 강제로 빼앗을 수 없다.
- 순환 대기
  - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

### 교착상태 처리방법

- 교착상태를 미리 예방

  - 자원 할당 시 4가지 조건 중 어느 하나가 만족되지 않도록 한다.

    1. 상호 배제 : 공유해서는 안되는 자원의 경우 상호배제를 피할 수 없다. 보통 나머지 조건들을 통해 예방한다.

    2. 점유 대기: 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 한다.

       e.g 1. 프로세스 시작 시 필요한 모든 자원을 할당 받는다.

       e.g 2. 자원이 필요할 경우 보유 자원을 반납하고 다시 요청한다.

    3. 비선점: 프로세스가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점된다.(보유 자원을 뺏긴다. 보유 자원은 save, restore가 쉬워야 한다.)

    4. 순환 대기: 모든 자원에 할당 순서를 정하여 정해진 순서대로만 자원 할당

       e.g 순서가 3인 자원 Ri를 보유한 프로세스가 순서가 1인 자원 Rj를 할당 받기 위해서는 우선 Ri를 반납해야 한다.

  - 문제점: 자원 이용률 저하, 시스템 처리율 감소, 기아 문제

- 교착상태 발생을 회피

  - 자원 요청에 대한 부가적인 정보를 이용해서 교착상태의 가능성이 없는 경우에만 자원을 할당한다.
  - 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원을 할당한다.
  - [은행원 알고리즘](#은행원-알고리즘)

- 교착상태 탐지 및 회복

  - 교착상태 발생은 허용하나, 그에 대한 탐지 루틴을 두어 교착상태를 회복시킨다.
  - 교착상태 프로세스 전부 끄거나, 교착상태가 풀릴 때까지 프로세스를 하나씩 끈다.

- 교착상태 무시

  - 교착상태를 시스템이 책임지지 않는다.
  - UNIX를 포함한 대부분의 OS가 채택

#### 은행원 알고리즘

- 가정
  - 모든 프로세스는 자원의 최대 사용량을 미리 명시
  - 프로세스가 요청 자원을 모두 할당받은 경우 유한 시간 안에 이들 자원을 다시 반납한다.
- 방법
  - 자원 요청시 safe 상태를 유지할 경우에만 자원 할당
  - 총 요청 자원의 수가 가용 자원의 수 보다 적은 프로세스를 선택, 없으면 unsafe
  - 선택한 프로세스에게 자원 할당
  - 프로세스가 종료되면 모든 자원을 반납
  - 모든 프로세스가 종료될 때까지 과정 반복

<img src="https://user-images.githubusercontent.com/80962918/137317394-38aa383f-cded-40ea-96ab-40c7d05f15ee.png" style width="600"/>

|          | step 1       | step 2       | step 3       | step 4 | step 5 |
| -------- | ------------ | ------------ | ------------ | ------ | ------ |
| 가용자원 | 3 3 2        | 5 3 2        | 7 4 3        | 7 4 5  | 9 4 5  |
| P0       | x            | x            | o            | o      | o      |
| P1       | o            | -            | -            | -      | -      |
| P2       | x            | x            | o            | o      | -      |
| P3       | o            | o            | -            | -      | -      |
| P4       | x            | o            | o            | -      | -      |
| 결과     | P1 선택 반납 | P3 선택 반납 | P4 선택 반납 | P2     | P0     |

</br>

## 김현수

### 교착상태(Deadlock)란?
- 상호배제에 의해 나타나는 문제점으로, 다중 프로그래밍 시스템에서 여러 프로세스들이 공유하고 있는 일부 자원들을 점유하고 놓지 않으면서 다른 프로세스가 가지고 있는 자원들을 원하여 무한정으로 기다리고 있는 상태
- 프로세스 상태전이도의 프로세스 상태 중 Asleep 상태에 해당
	- 프로세스가 실행하기 위해 필요한 자원을 갖지 못한 상태이므로 Asleep 상태 또는 Suspended Blocked 상태로도 될 수 있으며, 자원을 다시 얻게 되면 Wake up 된다.

### 교착상태의 발생 조건
1. 상호배제(Mutual Exclusion, Mutex)
	- 둘 이상의 프로세스가 임계 영역에 동시에 접근하는 것을 금지시키는 기법.
2. 점유와 대기(Hold and Wait)
	- 자원을 가지고 있는 상태에서 다른 프로세스가 사용하고 있는 자원의 반납을 기다리는 것.
3. 비선점(Non Preemptive)
	- 다른 프로세스의 자원을 강제로 가져올 수 없음
4. 환형대기(Circular Wait)
	- 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있는 것
	
### 교착상태 해결 방법
1. 예방(Prevention)
	- 교착상태의 발생 조건은 위의 네 가지 조건을 모두 만족시키는 경우이므로 교착상태를 해결하기 위해서는 네 조건 중 하나만 해결하면 된다.
2. 회피(Avoidance)
	- 교착상태의 발생조건을 없애기보다는 발생하지 않도록 알고리즘을 적용하는 방법
	- ex. 자원할당 그래프 알고리즘, 은행원 알고리즘
3. 회복(Recovery)
	- 교착상태가 발생하는 것을 아예 막지 않고, 만약 교착상태가 발생하면 발생 이후에 문제를 해결하는 방법
4. 무시(Ignore)
	- 교착상태를 해결할때에도 믄맥교환에 의한 오버헤드로 성능 저하가 생긴다.
	- 따라서 교착상태에 의한 성능 저하보다 이를 해결할 때의 성능저하가 더 큰 경우엔 그냥 무시한다.

## 이수형

### 교착상태

둘 이상의 프로세스가 상대방의 점유가 끝나기까지 서로 기다려서 무한대기에 빠지는 상태

### 발생 조건

교착상태가 되려면 다음의 네가지 조건이 모두 충족되어야함

- 상호 배제

   - 한번에 하나의 프로세스만이 자원을 사용할수 있어야함
- 점유 대기

   - 최소 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당된 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야함

- 비선점
   - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

- 환형 대기
   - 각 프로세스는 공유자원을 사용하기 위해 원형으로 구성되어 있어서 순환적으로 자신 앞이나 뒤의 프로세스의 자원을 가지고 있어야함

### 예방

- 상호배제 방지

   - 한번에 여러 프로세스가 공유자원을 사용할 수 있게함
- 점유 대기 방지
   - 프로세스가 실행되기전 필요한 모든 자원을 할당하여 대기를 없앰
   - 자원이 점유되지 않은 상태에서만 자원을 요구하도록 함
- 비전섬 방지
   - 자원을 점유하고 있는 프로세스가 다른 자원을 요구할때 현재 점유한 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 함
- 환형 대기 방지
   - 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구해야함

### 회피

- 교착상태가 발생할 가능성을 배제시키지 않고 교착상태 발생시 적절히 피해가는방법

- 은행원 알고리즘

### 발견

- 시스템이 교착상태가 발생했는지를 점검하여 교착상태의 프로세스와 자원을 발견하는방법

- 발견 알고리즘, 자원할당 그래프

### 회복

- 교착상태를 일으킨 프로세스를 종료

- 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스 자원을 회복

> 선점시 고려사항<br/>
> 자원을 선점할 프로세스의 선택 문제 : 최소 피해를 주는 프로세스 선택<br/>
> 자원을 선점한 프로세스의 복귀 문제  : 일시 중지후 다시시작하는 방법 사용<br/>기아 현상 문제 : 한 프로세스가 계속해서 선점대상이 되면 안됨
## 우지현

### 교착 상태 (Deadlock)

- 시스템 자원에 대한 요구가 뒤엉킨 상태
- 즉, 둘 이상의 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황

### 교착 상태의 발생 조건

- 상호 배제 (Mutual exclusion)
  - 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.
  - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.
- 점유 대기 (Hold and wait)
  - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
- 비선점 (No preemption)
  - 이미 할당된 자원을 강제로 빼앗을 수 없다.
- 순환 대기 (Circular wait)
  - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

### 교착 상태의 해결법

- 데드락이 발생하지 않도록 `예방(prevention)`하기
- 데드락 발생 가능성을 인정하면서도 적절하게 `회피(avoidance)` 하기
- 데드락 발생을 허용하지만 데드락을 `탐지(detection)`하며 데드락에서 `회복(recovery)` 하기

### 교착 상태 예방 (Prevention)

교착 상태의 발생조건 4가지 중 하나라도 발상하지 않게 하는 것이 예방하는 방법이다. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

- 자원의 `상호 배제` 조건 방지 
  - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
  - 그러나 추후 동기화 관련 문제가 발생할 수 있다.
- `점유 대기` 조건 방지
  - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해서, 나중에 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.
- `비선점` 조건 방지
  - 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.
- `순환 대기` 조건 방지
  - 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.

이러한 조건을 방지해서 교착 상태를 예방하는 방법은 시스템의 처리량이나 효율성을 떨어트리는 단점이 발생할 수 있다.

### 교착 상태 회피 (Avoidance)

교착 상태 회피법은 예방법보다는 조금 덜 제한적인 방법으로 예방법의 단점을 일부 해결할 수 있다. 회피법에서는 `Safe sequence`, `Safe state` 등이 키워드이다.

- `안정 상태 (Safe state)` : 시스템의 프로세스들의 요청하는 모든 자원을 교착 상태를 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있는 상태
- `안전 순서(Safe sequence)` : 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 교착 상태가 발생하지 않는 순서
- `불안정 상태` : 안정 상태가 아닌 상황. 교착 상태 발생 가능성이 있는 상황이며, 교착 상태는 불안정 상태일 때 발생. 불안정 상태가 교착 상태보다 좀 더 큰 집합이다. (즉, 교착 상태가 불안정 상태의 부분 집합이다.)

회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 `Safe state`에 있을 수 있도록 할당을 허용하자는 것이 특징이다. 이러한 특징을 살린 알고리즘으로 유명한 것이 `은행원 알고리즘`이다.

#### 은행원 알고리즘 (Banker's Algorithm)

- 다익스트라가 제안한 기법
- 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 `Safe state`에 들 수 있는지 여부 검사
- 즉, 대기 중인 다른 프로세스들의 활동에 대한 교착 상태 가능성을 미리 조사하는 방법
- 안정 상태면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기한다.
- 단점
  - 미리 자원의 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 한느 등 사,용에 있어 제약조건이 많고, 그에 따른 자원 이용도 하락

### 교착 상태 탐지(Detection) 및 회복(Recovery)

시스템이 데드락 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으니 여기에서 회복하기 위해 데드락을 탐지하고, 회복하는 알고리즘을 사용한다.

- 탐지 기법
  - Allocation, Request, Available 등으로 시스템에 교착 상태가 발생했는지 여부를 탐색한다.
  - 즉, 은행원 알고리즘에서 했던 방식과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.
  - 이외에도 자원 할당 그래프를 통해 탐지하는 방법도 있다.
- 회복 기법
  - 교착 상태를 탐지 기법을 통해 발견했다면, `순환 대기`에서 벗어나 교착 상태로부터 회복하기 위한 방법을 사용한다.
  - 단순히 프로세스를 1개 이상 중단
    - 교착 상태에 빠진 모든 프로세스를 중단시키는 방법
      - 계속 연산 중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있다.
    - 프로세스를 하나씩 중단시킬 때마다 탐지 알고리즘으로 교착 상태를 탐지하면서 회복시키는 방법
      - 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있다.
  - 자원 선점
    - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법


## 윤기재

### 데드락(Deadlock)
- 운영체제에서 데드락(교착상태)이란, 시스템 자원에 대한 요구가 뒤엉킨 상태
- 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황.
![화면 캡처 2021-10-18 191414](https://user-images.githubusercontent.com/37038119/137712275-0dc59ab0-9adf-4de2-a3d4-3d4ece254ecc.png)

[이미지출처:https://velog.io/@tails5555/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%A0%95%EB%A6%AC]


### 데드락(Deadlock)의 발생조건

#### 상호 배제
- 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

#### 점유 대기
- 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.

#### 비선점
- 이미 할당된 자원을 강제로 빼앗을 수 없다(비선점).

#### 순환 대기
- 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. 
<br/>


### 데드락 예방(Prevention)
교착 상태 발생 조건 4 가지 중 하나를 없애면 된다.

### 데드락 회피(Avoidance)
회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용

안정 상태(safe state) : 시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있는 상태

안전 순서(safe sequence) : 특정한 순서로 프로세스들에게 자원을 할당, 실행 및 종료 등의 작업을 할 때 데드락이 발생하지 않는 순서

불안정 상태 : 드락 발생 가능성이 있는 상황이며, 교착 상태(데드락)는 불안정 상태일 때 발생할 수 있다.

> ex)
은행원 알고리즘(Banker’s Algorithm)
미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사한다.

### 데드락 탐지(Detection) 
교착 상태 발생 여부를 계속 탐색을 하는 방식이다.  여기서 교착 상태가 발견되면 즉시 회복 시켜야 한다.  

### 데드락 회복(Recovery)
- 교착 상태를 일으킨 프로세스들에 한해서 아래와 같이 해결한다.
	 - 전체 책임 : 교착 상태에 문제가 되었던 프로세스들을 종료한다.
	- 일부 책임 : 우선 순위, 작업 시간, 자원 활용도 등을 따진 뒤 최저 등급을 맞은 프	로세스를 종료한다.

교착 상태 탐지, 희생자 선정 알고리즘을 계속 실행하여 해결해야 하기 때문에 오버헤드를 감수해야 한다.

<br>

## 이유진
### 교착상태 (Deadlock)
- 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 각자의 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하여 무한정 대기하는 현상이다.
- 특히 하나의 자원을 공유하는 경우가 많은 멀티 스레드를 개발할 때 deadlock 문제의 발생 가능성이 높기 때문에, 염두해두고 있어야 한다.

### 교착상태 발생의 필요 충분 조건 4가지
> 네 가지 조건 중 하나라도 충족되지 않으면 교착상태가 발생하지 않는다.

- 상호배제 (Mutuel Exclusion) : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
- 점유와 대기 (Hold and Wait) : 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 하나 이상 있어야 한다.
- 비선점 (Non-preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
- 환형 대기 (Circular Wait) : 공유자원과 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F997664425C5935A0236E81)

### 예방 기법 (Preventation)
교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법이다. 4가지 발생 조건 중 하나를 제거하며 수행되고, 자원 낭비가 가장 심하다. (개발자의 역할)

### 회피 기법 (Avoidance)
교착상태가 발생하면 적절히 피해나가는 방법이다. (운영체제의 역할)
> #### 철학자 문제
> 철학자 수 == 젓가락 수 라고 가정  
> 원형으로 둘러 앉은 식탁에서 한 철학자가 왼쪽 젓가락(자원)을 요구한다. 이때, deadlock에 빠질 가능성이 없으면 (ex. 남는 젓가락이 있는 상태) 운영체제가 젓가락을 준다. 그런데, 마지막으로 앉은 철학자가 왼쪽 젓가락을 요청하면, deadlock에 빠질 가능성이 크기 때문에 운영체제는 젓가락을 주지 않는다.   

### 발견 및 회복 기법 (Detection and Recovery)
deadlock발생을 발견하면 교착 상태 프로세스들을 모두 중지하거나, 교착 상태가 해결될 때까지 한 프로세스씩 중지한다. 단, deadlock을 검사하며 큰 오버헤드를 갖는다.  
주기적으로 deadlock에 빠졌는지 검사를 한다. deadlock 발생을 발견(**Detect**)하면 deadlock이 발생하기 전 상태로 회복(**Recover**)하는 방법이다.  
> 위의 철학자 문제에서, 마지막 철학자에게까지 일단 젓가락을 다 준다. 이후, deadlock이 발견되면 그 전의 상황으로 복구한다.

#### 회복 방법
프로세스 또는 스레드 중 하나를 중지시켜서 강제로 자원을 내려놓게 한다.

> **고려사항**  
> 1. 최소의 피해를 줄 수 있는 프로세스(스레드)를 선택한다.
> 2. 대부분 프로세스(스레드)를 일시 중지시키고 다시 시작하는 방법을 사용한다.
> 3. 한 프로세스(스레드)가 계속해서 자원 선점 대상이 되지 못하도록 고려해야 한다.

### Do Nothing
운영체제가 아무것도 하지 않는 것. 개발자가 프로그램을 개발할 때 데드락에 빠질 가능성을 봉쇄해야 한다.
