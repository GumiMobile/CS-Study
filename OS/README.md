# Operating System
* [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
* [스케줄러](#스케줄러)
* [멀티쓰레드(장점, 단점)](#멀티쓰레드장점-단점)
* [프로세스 동기화](#프로세스-동기화)
  * [프로세스 동기화란?](#프로세스-동기화란?)
  * [경쟁 조건](#경쟁-조건)
  * [스레드 동기화란?](#스레드-동기화란?)
  * [구역(Section)](#구역(section))
  * [임계구역 문제](#임계구역-문제)
  * [임계구역 문제 해결책](#임계구역-문제-해결책)
 
[뒤로](https://github.com/GumiMobile/CS-Study)

<br><br>
## 프로세스와 쓰레드의 차이

## 프로세스

OS로부터 자원(CPU시간, 운영에 필요한 주소 공간, [Code,Data,Stack,Heap]의 구조로 된 독립된 메모리 영역)을 할당받는 작업의 단위

하나의 쓰레드가 기본생성되기때문에 하나이상의 쓰레드를 보유함

- Code : 프로세스의 정의, 명령
- Data : 프로그램이 사용하는 정적 변수
- Stack : 함수의 호출, 반환에 따라 쌓이고 줄어드는 메모리 영역
- Heap : 프로그램이 사용하는 동적 변수( 프로그램이 변수 공간을 할당하면 이곳에 할당 )

각 프로세스는 서로다른 PID가 있고, OS가 안정성을위해 다른 프로세스가 침범하지 못하도록 제약을 두고있다. 다른 프로세스의 변수나 자료 구조에 접근하려면 프로세스 간의 통신을 사용해야 한다.

### 프로세스 context

운영체제는 하나의 CPU로 여러 개의 프로세스를 구동하기 위해 시분할 방식을 사용한다
CPU는 매우 빠른 속도로 연산할 수 있으므로 아주 잠깐씩 여러개를 실행하면, 사용자는 동시에 여러개가 실행되는 것으로 느낀다.

이때 프로세스 문맥(context) 라는것이 사용되는데 이전의 CPU보유 시점에서 프로세스의 상태를 재현하기 위해 사용된다

현재까지 무엇을 어떻게 실행했는지 정확하게 나타내기 위해 사용된다

- ex) Code에서 함수호출시 stack에 쌓인내용, data영역에서 변경된 변수의 값, 레지스터에 어떤 값을넣고 어떤 명령까지 실행했는가 등에 대한 정보

### 스케줄링

어떤 프로세스를 더 먼저 or 더 길게 실행할 것인지 스스로 판단하며 이에 관련된 다양한 CPU 스케줄링 기법이 존재한다.

장기,중기,단기 3가지 단계의 각각 알고리즘이 많이있다 선입선출, 라운드로빈 등

## 쓰레드

프로세스가 할당받은 자원을 이용하는 흐름 단위이다. 

여러개의 쓰레드가 있을수 있으며 같은 프로세스 안에서 쓰레드끼리는 Code, Data, Heap 자원을 공유하면서 Stack만 따로 할당받기때문에 한 쓰레드가 자원을 변경할시에 다른 쓰레드에서 즉각 그 결과를 알수 있다.
단, 자원을 공유하므로 동기화 문제가 발생할 수 있다.
즉 어플리케이션 하나가 프로세스이고, 그 안에서의 분기 처리가 쓰레드가 된다.

또한 프로세스 간의 전환 속도보다 쓰레드 간의 전환 속도가 빠르다.

## 멀티프로세스 vs 멀티쓰레드

- 메모리 효율 → 멀티쓰레드 Win!
- 상호간 통신 → 멀티쓰레드 Win!
- 안정성 → 멀티프로세스 Win!

스레드 사이의 통신은 공유 메모리를 통해 쉽게 통신할 수 있지만, 프로세스 사이의 통신은 IPC등의 기술을 사용해야 한다.

결합도의 관점에서, 멀티스레드 사용시 동기화 이슈가 발생할 수 있다.

또한 멀티쓰레드는 스케줄링을 운영체제가 자동으로 해주지 않고, 프로그래머가 적절한 기법을 선택하여 직접 구현해야하므로 프로그램을 멀티 스레드로 개발할 때는 신중해야한다.

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)
<br><br>

## 스케줄러

### 스케줄러(Scheduler)란?

- **한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록** 다음 실행 시간에 실행할 수 있는 프로세스 중에 **하나를 결정**하는 운영체제 커널의 코드이다.
- **프로세스를 관리하는 Queue**에는 다음 세 가지 종류가 있다.

> `Job Queue` :  현재 시스템 내에 있는 **모든 프로세스의 집합**
>
> `Ready Queue` : 현재 메모리 내에서 **CPU를 할당받기를 기다리는 프로세스의 집합**.  앞에 있는 순서대로 OS로부터 CPU를 할당받아 실행된다.
>
> `Device Queue` : **Device I/O 작업을 대기하고 있는 프로세스의 집합**

![image](https://user-images.githubusercontent.com/76988389/134460682-49f86127-ea73-4373-88c4-cf7ad340c0a2.png)

### 장기 스케줄러(Long-Term Scheduler)

- 지금 수행해야 할 job Pool 중에 어떤 것을 메모리에 올릴지 결정한다.**(디스크 - 메모리 스케줄링)**
- 프로세스에 메모리 및 각종 리소스를 할당한다.**(admit)**
- job을 골라서 ready queue에 보내기 때문에 **job scheduler**라고도 부른다.
- CPU의 계산 작업이 필요한 **CPU bound process**만 메모리에 올라가면 사용자와 실시간 상호작용이 어렵다.
- **I/O bound process**만 메모리에 올라가면 입출력을 기다리느라 CPU가 놀게 된다.
- 이를 적절한 비율로 메모리에 적재하는 것이 장기 스케줄러의 역할이다.
- 이 때, 프로세스의 상태는 **new -> ready(in memory) 상태**가 된다.

- **호출빈도 매우 적다.** 또한, **오늘날**에는 가상 메모리 관리(virtual memory management)가 발달해서 모든 job이 메모리에 올라가므로, **장기 스케줄러는 거의 사용되지 않는다.**



### 단기 스케줄러(Short-Term Scheduler)

- CPU는 한 번에 하나의 process만 수행한다.
- 장기 스케줄러에 의해 메모리에 올라간 process들 중, 어떤 걸 먼저 처리할지 결정하는 것이 단기 스케줄러의 역할이다.**(메모리 - CPU 스케줄링)**
- Ready Queue의 프로세스 중 어떤 프로세스에 CPU를 할당해서 running할 지 결정한다.**(scheduler dispatch)**
- 가상 메모리 관리의 발달로 Short-Term/Long-Term 구분이 없는 요즘은, **CPU scheduler**라고도 부른다.
- 이 때, 프로세스의 상태는 **ready -> running -> waiting -> ready**가 된다.
- **호출빈도가 높다.** 특히 **오늘날** 단기 스케줄러로 거의 모든 프로세스가 제어된다.



### 중기 스케줄러(Mid-Term Scheduler)

- CPU는 한 번의 하나의 process만 수행하는데, 사용자의 다중 작업을 지원하기 위해 메모리에 올라간 작업들 중 단기 스케줄러에 의해 먼저 처리할 작업을 선정하고, 아주 짧은 시간동안 수행하기를 반복한다.
- 즉, 단기 스케줄러가 수행할 process를 정해준다고 해도, 그 process가 끝날때까지 계속 수행하는게 아니다.
- 따라서 **CPU가 감당하기 어려울 만큼의 job이 메모리에 올라오면, 우선순위가 낮은 job은 잠시 내려뒀다가 나중에 다시 올리는 (swap) 작업을 통해 작업 효율을 높일 수 있다.**
- 이 일을 해주는 것이 중기 스케줄러이다. 역할 때문에 **swapper**라고도 부른다.
- 프로세스의 상태는 **ready -> suspended**가 된다.
- **장기 스케줄러와 마찬가지로 가상 메모리 관리가 발달하면서 사용되지 않는다.**

> `Process state - suspended`
>
> Suspended (stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태 의미한다. 프로세스 전부 디스크로 swap out 된다. blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.


[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)
<br><br>

## 멀티쓰레드(장점, 단점)

### 멀티쓰레드의 의미
하나의 응용 프로그램에서 여러 쓰레드를 구성해 각 스레드가 하나의 작업을 처리하는 것.
쓰레드 간 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상 시킨다.
> 멀티 프로세스 : 여러 개의 CPU를 사용하여 어러 프로세스를 동시에 수행하는 것.

### 멀티쓰레드 장점
- 응답성 : 프로그램의 일부 작업이 중단되거나 처리 과정이 오래 걸려도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다.
- 멀티프로세서 활용 : 다중 CPU 구조에서는 각각의 쓰레드가 다른 프로세서에서 병렬로 수행될 수 있다.
- 쓰레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유한다.
	- 메모리나 시스템 자원의 낭비가 적다. (중복되는 자원의 생성과 관리 최소화)
	- 통신이 필요한 경우에 전역 변수 또는 힙 영역을 이용하여 쉽게 데이터를 주고받을수 있다.
- 쓰레드의 context switch는 캐시 메모리를 비울 필요가 없다.
	- 시스템 처리량이 향상되고 자원 소모가 줄어들어 프로그램의 응답 시간이 단축된다.
- 코드 공유를 통해 한 응용프로그램 같은 주소공간내에서 여러개의 다른 활동성 쓰레드를 가질 수 있다.


### 멀티쓰레드 단점
- 동시접근 문제 : 서로 다른 쓰레드가 데이터와 힙 영역을 공유하므로 한 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.
- 멀티 쓰레드 프로그램은 실행 순서가 보장되지 않는다.
- 동기화(Mutex, Semaphore)를 통해 작업처리나 메모리 접근을 컨트롤 할 수 있으나 설계가 어려우며, 불필요한 부분까지 동기화를 할 경우 과도한 LOCK으로 인해 병목현상을 일으켜 성능이 저하될 수 있다
- 싱글코어에서의 멀티쓰레드의 경우 오히려 쓰레드 생성시간이 오버헤드로 작용하여 단일쓰레드보다 느리다.

> - Mutex
>   - 쉽게 말해 Key가 하나뿐인 메커니즘
>   - Key를 이용하여 접근컨트롤 Key가 있는 쓰레드만이 자원에 접근가능
>   -접근이 끝났을때 wait를 호출한 쓰레드만 해제(Key넘기기) 가능
>
> - Semaphore
>   - 쉽게 말해 Key가 여러개인 메커니즘
>   - Lock을 걸지 않은 쓰레드(wait호출x)도 Key넘기기 가능

### 멀티 프로세스 vs 멀티 쓰레드

|      |                멀티 프로세스 (Multi Process)                 |                  멀티 쓰레드 (Multi Thread)                  |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 장점 | 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다. | 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환(context switching)이 빠르다. |
| 단점 |   멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다.    | 오류로 인해 하나의 쓰레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제가 있다. |

> 💡 Context Switching이란?
  >
  > 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정
  >
  > 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말한다.
  >
  > 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생하는 문제가 존재한다.

멀티 쓰레드와 멀티 프로세스는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)
<br><br>

### 프로세스 동기화란?

- 하나의 자원을 한 순간에 하나의 프로세스만이 이용하도록 제어하는 것을 말한다.
- 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상황을 `Race Condition(경쟁 조건)`이라고 한다.
- 프로세스/스레드 동기화를 통해 `데이터의 일관성을 유지`할 수 있다. (결합도↓)



[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)



### 경쟁 조건

다음 상황들에 있어서 경쟁 조건이 발생할 수 있다.

**커널 수행중 인터럽트 발생**

`Solution` 커널 수행중에 인터럽트가 걸려도 무시하고 작업이 끝난 후 처리

**프로세스가 System Call 하여 커널 모드로 수행 중 context switch가 일어나는 경우**

`Solution` 커널 모드에 있는 경우 CPU 시간이 끝나도 할당된 CPU를 작업 종료시까지 유지

**멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근**

`Solution` 커널 내부의 각 공유 데이터에 접근할 때마다 해당 데이터를 lock/unlock (접근 차단/해제)



[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)



### 스레드 동기화란?

- 하나의 코드블록 또는 메소드를 한 순간에 하나의 스레드만이 이용하도록 제어하는 것을 말한다.



[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)



### 구역(Section)

- `임계구역(critical section)` : 공유 자원에 접근하는 코드의 일부를 말한다.
- `입장구역(entry section)` : 각 프로세스가 자신의 임계구역으로 진입할 때 진입 허가를 요청하는 부분을 말한다.
- `퇴장구역(exit section)` : 코드 실행을 마친 후 임계구역을 나오기 전 실행해야 하는 코드를 말한다.
- `나머지구역(remainder section)` : 다른 프로세스 및 공유데이터와 상관이 없는 코드를 말한다.



[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)



### 임계구역 문제

**임계구역으로 지정되어야 할 코드 영역이 임계구역으로 지정되지 않았을 때 발생하는 문제**를 말한다.

**임계구역 문제를 해결하기 위한 필요조건**은 다음과 같다.

- **상호 배제(Mutual exclusion)** : 하나의 프로세스가 임계구역에 들어가 있다면 다른 프로세스는 들어갈 수 없다.
- **진행(Progress)** : 임계구역에 들어간 프로세스가 없을 때, 들어가려는 프로세스가 여러 개 있다면 어느 것이 들어갈지를 적절히 결정해줘야 한다.
- **한정 대기(Bounded waiting)** : 모든 프로세스가 평등하게 공유 데이터에 접근하는 것을 보장하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음 번 입장 시 제한을 두어야 한다.



[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)



### 임계구역 문제 해결책

**소프트웨어적인 방법** 

- 프로세스가 2개일 때
  - `피터슨의 알고리즘` : flag값을 이용한 상호 배제를 만족하는 병렬 프로그래밍 기법이다.
```java
do{
flag[i]=true;// i 가 사용하고싶어함
trun =j;// i가 쓰고싶다고 설언해주고 j차례로 돌려서 혹시 다른프로세스가 쓰고싶나 확인
while(flag[j]&&trun==j);//자기 턴일때까지 spinlock에 머물러야함 여기서 cpu낭비를함
//임계영역 사용
flag[i]=false;//사용이 끝나면 해제
//나옴
}while(true)
```
  - `데커의 알고리즘` : 피터슨의 알고리즘과 비슷하다.
- 프로세스가 2개 이상일 때
  - `램포트의 빵집 알고리즘`

**하드웨어적인 방법**

- `동기화 명령어` 멀티 프로세서 환경에서는 시스템 효율성 때문에 인터럽트를 막을 수 없으므로, CPU 차원에서 지원하는 동기화 명령어를 활용하는 방법이다. 주로 `TestAndSet()`과 `Swap()` 명령어로 이를 구현한다.
- `Semaphores(세마포어)` 원자적 함수를 통해 제어되는 변수값을 말한다.
  - 이진 세마포어 : Mutex LOCK처럼 0이면 락 1이면 unlock
  - 카운팅 세마포어 : n개의 자원을 locking 하나의 자원할당시 n-1, 두개는 n-2 이런식으로 0까지 할당가능
  - 둘이상의 프로세스가 무한정 대기하는 Dead Lock에 걸릴 수 있음 이때는 시간을 우선순위로 두어 해결
- `모니터` 고급 언어에서 지원하는 기능 또는 모듈로써, 한 번에 하나의 프로세스만 활동하도록 보장해준다. (개발자의 코드를 상호 배제하도록 추상화된 데이터 형태)
- `LOCK/UNLOCK`



[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)

