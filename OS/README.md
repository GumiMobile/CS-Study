# Operating System
- [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
- [스케줄러](#스케줄러)
- [멀티쓰레드(장점, 단점)](#멀티쓰레드장점-단점)
 
[뒤로](https://github.com/GumiMobile/CS-Study)

<br><br>
## 프로세스와 쓰레드의 차이

## 프로세스

OS로부터 자원(CPU시간, 운영에 필요한 주소 공간, [Code,Data,Stack,Heap]의 구조로 된 독립된 메모리 영역)을 할당받는 작업의 단위

하나의 쓰레드가 기본생성되기때문에 하나이상의 쓰레드를 보유함

- Code : 프로세스의 정의, 명령
- Data : 프로그램이 사용하는 정적 변수
- Stack : 함수의 호출, 반환에 따라 쌓이고 줄어드는 메모리 영역
- Heap : 프로그램이 사용하는 동적 변수( 프로그램이 변수 공간을 할당하면 이곳에 할당 )

각 프로세스는 서로다른 PID가 있고, OS가 안정성을위해 다른 프로세스가 침범하지 못하도록 제약을 두고있다. 다른 프로세스의 변수나 자료 구조에 접근하려면 프로세스 간의 통신을 사용해야 한다.

### 프로세스 context

운영체제는 하나의 CPU로 여러 개의 프로세스를 구동하기 위해 시분할 방식을 사용한다
CPU는 매우 빠른 속도로 연산할 수 있으므로 아주 잠깐씩 여러개를 실행하면, 사용자는 동시에 여러개가 실행되는 것으로 느낀다.

이때 프로세스 문맥(context) 라는것이 사용되는데 이전의 CPU보유 시점에서 프로세스의 상태를 재현하기 위해 사용된다

현재까지 무엇을 어떻게 실행했는지 정확하게 나타내기 위해 사용된다

- ex) Code에서 함수호출시 stack에 쌓인내용, data영역에서 변경된 변수의 값, 레지스터에 어떤 값을넣고 어떤 명령까지 실행했는가 등에 대한 정보

### 스케줄링

어떤 프로세스를 더 먼저 or 더 길게 실행할 것인지 스스로 판단하며 이에 관련된 다양한 CPU 스케줄링 기법이 존재한다.

장기,중기,단기 3가지 단계의 각각 알고리즘이 많이있다 선입선출, 라운드로빈 등

## 쓰레드

프로세스가 할당받은 자원을 이용하는 흐름 단위이다. 

여러개의 쓰레드가 있을수 있으며 같은 프로세스 안에서 쓰레드끼리는 Code, Data, Heap 자원을 공유하면서 Stack만 따로 할당받기때문에 한 쓰레드가 자원을 변경할시에 다른 쓰레드에서 즉각 그 결과를 알수 있다.
단, 자원을 공유하므로 동기화 문제가 발생할 수 있다.
즉 어플리케이션 하나가 프로세스이고, 그 안에서의 분기 처리가 쓰레드가 된다.

또한 프로세스 간의 전환 속도보다 쓰레드 간의 전환 속도가 빠르다.

## 멀티프로세스 vs 멀티쓰레드

- 메모리 효율 → 멀티쓰레드 Win!
- 상호간 통신 → 멀티쓰레드 Win!
- 안정성 → 멀티프로세스 Win!

스레드 사이의 통신은 공유 메모리를 통해 쉽게 통신할 수 있지만, 프로세스 사이의 통신은 IPC등의 기술을 사용해야 한다.

결합도의 관점에서, 멀티스레드 사용시 동기화 이슈가 발생할 수 있다.

또한 멀티쓰레드는 스케줄링을 운영체제가 자동으로 해주지 않고, 프로그래머가 적절한 기법을 선택하여 직접 구현해야하므로 프로그램을 멀티 스레드로 개발할 때는 신중해야한다.

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)
<br><br>

## 스케줄러

### 스케줄러(Scheduler)란?

- **한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록** 다음 실행 시간에 실행할 수 있는 프로세스 중에 **하나를 결정**하는 운영체제 커널의 코드이다.
- **프로세스를 관리하는 Queue**에는 다음 세 가지 종류가 있다.

> `Job Queue` :  현재 시스템 내에 있는 **모든 프로세스의 집합**
>
> `Ready Queue` : 현재 메모리 내에서 **CPU를 할당받기를 기다리는 프로세스의 집합**.  앞에 있는 순서대로 OS로부터 CPU를 할당받아 실행된다.
>
> `Device Queue` : **Device I/O 작업을 대기하고 있는 프로세스의 집합**

![image](https://user-images.githubusercontent.com/76988389/134460682-49f86127-ea73-4373-88c4-cf7ad340c0a2.png)

### 장기 스케줄러(Long-Term Scheduler)

- 지금 수행해야 할 job Pool 중에 어떤 것을 메모리에 올릴지 결정한다.**(디스크 - 메모리 스케줄링)**
- 프로세스에 메모리 및 각종 리소스를 할당한다.**(admit)**
- job을 골라서 ready queue에 보내기 때문에 **job scheduler**라고도 부른다.
- CPU의 계산 작업이 필요한 **CPU bound process**만 메모리에 올라가면 사용자와 실시간 상호작용이 어렵다.
- **I/O bound process**만 메모리에 올라가면 입출력을 기다리느라 CPU가 놀게 된다.
- 이를 적절한 비율로 메모리에 적재하는 것이 장기 스케줄러의 역할이다.
- 이 때, 프로세스의 상태는 **new -> ready(in memory) 상태**가 된다.

- **호출빈도 매우 적다.** 또한, **오늘날**에는 가상 메모리 관리(virtual memory management)가 발달해서 모든 job이 메모리에 올라가므로, **장기 스케줄러는 거의 사용되지 않는다.**



### 단기 스케줄러(Short-Term Scheduler)

- CPU는 한 번에 하나의 process만 수행한다.
- 장기 스케줄러에 의해 메모리에 올라간 process들 중, 어떤 걸 먼저 처리할지 결정하는 것이 단기 스케줄러의 역할이다.**(메모리 - CPU 스케줄링)**
- Ready Queue의 프로세스 중 어떤 프로세스에 CPU를 할당해서 running할 지 결정한다.**(scheduler dispatch)**
- 가상 메모리 관리의 발달로 Short-Term/Long-Term 구분이 없는 요즘은, **CPU scheduler**라고도 부른다.
- 이 때, 프로세스의 상태는 **ready -> running -> waiting -> ready**가 된다.
- **호출빈도가 높다.** 특히 **오늘날** 단기 스케줄러로 거의 모든 프로세스가 제어된다.



### 중기 스케줄러(Mid-Term Scheduler)

- CPU는 한 번의 하나의 process만 수행하는데, 사용자의 다중 작업을 지원하기 위해 메모리에 올라간 작업들 중 단기 스케줄러에 의해 먼저 처리할 작업을 선정하고, 아주 짧은 시간동안 수행하기를 반복한다.
- 즉, 단기 스케줄러가 수행할 process를 정해준다고 해도, 그 process가 끝날때까지 계속 수행하는게 아니다.
- 따라서 **CPU가 감당하기 어려울 만큼의 job이 메모리에 올라오면, 우선순위가 낮은 job은 잠시 내려뒀다가 나중에 다시 올리는 (swap) 작업을 통해 작업 효율을 높일 수 있다.**
- 이 일을 해주는 것이 중기 스케줄러이다. 역할 때문에 **swapper**라고도 부른다.
- 프로세스의 상태는 **ready -> suspended**가 된다.
- **장기 스케줄러와 마찬가지로 가상 메모리 관리가 발달하면서 사용되지 않는다.**

> `Process state - suspended`
>
> Suspended (stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태 의미한다. 프로세스 전부 디스크로 swap out 된다. blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.


[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)
<br><br>

## 멀티쓰레드(장점, 단점)

### 멀티쓰레드의 의미
하나의 응용 프로그램에서 여러 쓰레드를 구성해 각 스레드가 하나의 작업을 처리하는 것.
쓰레드 간 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상 시킨다.
> 멀티 프로세스 : 여러 개의 CPU를 사용하여 어러 프로세스를 동시에 수행하는 것.

### 멀티쓰레드 장점
- 응답성 : 프로그램의 일부 작업이 중단되거나 처리 과정이 오래 걸려도 프로그램의 수행이 계속되어 사용자에 대한 응답성이 증가한다.
- 멀티프로세서 활용 : 다중 CPU 구조에서는 각각의 쓰레드가 다른 프로세서에서 병렬로 수행될 수 있다.
- 쓰레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유한다.
	- 메모리나 시스템 자원의 낭비가 적다. (중복되는 자원의 생성과 관리 최소화)
	- 통신이 필요한 경우에 전역 변수 또는 힙 영역을 이용하여 쉽게 데이터를 주고받을수 있다.
- 쓰레드의 context switch는 캐시 메모리를 비울 필요가 없다.
	- 시스템 처리량이 향상되고 자원 소모가 줄어들어 프로그램의 응답 시간이 단축된다.
- 코드 공유를 통해 한 응용프로그램 같은 주소공간내에서 여러개의 다른 활동성 쓰레드를 가질 수 있다.


### 멀티쓰레드 단점
- 동시접근 문제 : 서로 다른 쓰레드가 데이터와 힙 영역을 공유하므로 한 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.
- 멀티 쓰레드 프로그램은 실행 순서가 보장되지 않는다.
- 동기화(Mutex, Semaphore)를 통해 작업처리나 메모리 접근을 컨트롤 할 수 있으나 설계가 어려우며, 불필요한 부분까지 동기화를 할 경우 과도한 LOCK으로 인해 병목현상을 일으켜 성능이 저하될 수 있다
- 싱글코어에서의 멀티쓰레드의 경우 오히려 쓰레드 생성시간이 오버헤드로 작용하여 단일쓰레드보다 느리다.

> - Mutex
>   - 쉽게 말해 Key가 하나뿐인 메커니즘
>   - Key를 이용하여 접근컨트롤 Key가 있는 쓰레드만이 자원에 접근가능
>   -접근이 끝났을때 wait를 호출한 쓰레드만 해제(Key넘기기) 가능
>
> - Semaphore
>   - 쉽게 말해 Key가 여러개인 메커니즘
>   - Lock을 걸지 않은 쓰레드(wait호출x)도 Key넘기기 가능

### 멀티 프로세스 vs 멀티 쓰레드

|      |                멀티 프로세스 (Multi Process)                 |                  멀티 쓰레드 (Multi Thread)                  |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 장점 | 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다. | 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환(context switching)이 빠르다. |
| 단점 |   멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다.    | 오류로 인해 하나의 쓰레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제가 있다. |

> 💡 Context Switching이란?
  >
  > 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정
  >
  > 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말한다.
  >
  > 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생하는 문제가 존재한다.

멀티 쓰레드와 멀티 프로세스는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

[뒤로](https://github.com/GumiMobile/CS-Study) / [위로](#operating-system)
<br><br>

