# Operating System
- [프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)
- [스케줄러](#스케줄러)

<br><br>
## 프로세스와 쓰레드의 차이

## 프로세스

OS로부터 자원(CPU시간, 운영에 필요한 주소 공간, [Code,Data,Stack,Heap]의 구조로 된 독립된 메모리 영역)을 할당받는 작업의 단위

하나의 쓰레드가 기본생성되기때문에 하나이상의 쓰레드를 보유함

- Code : 프로세스의 정의, 명령
- Data : 프로그램이 사용하는 정적 변수
- Stack : 함수의 호출, 반환에 따라 쌓이고 줄어드는 메모리 영역
- Heap : 프로그램이 사용하는 동적 변수( 프로그램이 변수 공간을 할당하면 이곳에 할당 )

각 프로세스는 서로다른 PID가 있고, OS가 안정성을위해 다른 프로세스가 침범하지 못하도록 제약을 두고있다. 다른 프로세스의 변수나 자료 구조에 접근하려면 프로세스 간의 통신을 사용해야 한다.

### 프로세스 context

운영체제는 하나의 CPU로 여러 개의 프로세스를 구동하기 위해 시분할 방식을 사용한다
CPU는 매우 빠른 속도로 연산할 수 있으므로 아주 잠깐씩 여러개를 실행하면, 사용자는 동시에 여러개가 실행되는 것으로 느낀다.

이때 프로세스 문맥(context) 라는것이 사용되는데 이전의 CPU보유 시점에서 프로세스의 상태를 재현하기 위해 사용된다

현재까지 무엇을 어떻게 실행했는지 정확하게 나타내기 위해 사용된다

- ex) Code에서 함수호출시 stack에 쌓인내용, data영역에서 변경된 변수의 값, 레지스터에 어떤 값을넣고 어떤 명령까지 실행했는가 등에 대한 정보

### 스케줄링

어떤 프로세스를 더 먼저 or 더 길게 실행할 것인지 스스로 판단하며 이에 관련된 다양한 CPU 스케줄링 기법이 존재한다.

장기,중기,단기 3가지 단계의 각각 알고리즘이 많이있다 선입선출, 라운드로빈 등

## 쓰레드

프로세스가 할당받은 자원을 이용하는 흐름 단위이다. 

여러개의 쓰레드가 있을수 있으며 같은 프로세스 안에서 쓰레드끼리는 Code, Data, Heap 자원을 공유하면서 Stack만 따로 할당받기때문에 한 쓰레드가 자원을 변경할시에 다른 쓰레드에서 즉각 그 결과를 알수 있다.
단, 자원을 공유하므로 동기화 문제가 발생할 수 있다.
즉 어플리케이션 하나가 프로세스이고, 그 안에서의 분기 처리가 쓰레드가 된다.

또한 프로세스 간의 전환 속도보다 쓰레드 간의 전환 속도가 빠르다.

## 멀티프로세스 vs 멀티쓰레드

- 메모리 효율 → 멀티쓰레드 Win!
- 상호간 통신 → 멀티쓰레드 Win!
- 안정성 → 멀티프로세스 Win!

스레드 사이의 통신은 공유 메모리를 통해 쉽게 통신할 수 있지만, 프로세스 사이의 통신은 IPC등의 기술을 사용해야 한다.

결합도의 관점에서, 멀티스레드 사용시 동기화 이슈가 발생할 수 있다.

또한 멀티쓰레드는 스케줄링을 운영체제가 자동으로 해주지 않고, 프로그래머가 적절한 기법을 선택하여 직접 구현해야하므로 프로그램을 멀티 스레드로 개발할 때는 신중해야한다.

<br><br>

## 스케줄러

### 스케줄러(Scheduler)란?

- **한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록** 다음 실행 시간에 실행할 수 있는 프로세스 중에 **하나를 결정**하는 운영체제 커널의 코드이다.
- **프로세스를 관리하는 Queue**에는 다음 세 가지 종류가 있다.

> `Job Queue` :  현재 시스템 내에 있는 **모든 프로세스의 집합**
>
> `Ready Queue` : 현재 메모리 내에서 **CPU를 할당받기를 기다리는 프로세스의 집합**.  앞에 있는 순서대로 OS로부터 CPU를 할당받아 실행된다.
>
> `Device Queue` : **Device I/O 작업을 대기하고 있는 프로세스의 집합**



### 장기 스케줄러(Long-Term Scheduler)

- 지금 수행해야 할 job Pool 중에 어떤 것을 메모리에 올릴지 결정한다.**(디스크 - 메모리 스케줄링)**
- 프로세스에 메모리 및 각종 리소스를 할당한다.**(admit)**
- job을 골라서 ready queue에 보내기 때문에 **job scheduler**라고도 부른다.
- CPU의 계산 작업이 필요한 **CPU bound process**만 메모리에 올라가면 사용자와 실시간 상호작용이 어렵다.
- **I/O bound process**만 메모리에 올라가면 입출력을 기다리느라 CPU가 놀게 된다.
- 이를 적절한 비율로 메모리에 적재하는 것이 장기 스케줄러의 역할이다.
- 이 때, 프로세스의 상태는 **new -> ready(in memory) 상태**가 된다.

- **호출빈도 매우 적다.** 또한, **오늘날**에는 가상 메모리 관리(virtual memory management)가 발달해서 모든 job이 메모리에 올라가므로, **장기 스케줄러는 거의 사용되지 않는다.**



#### 단기 스케줄러(Short-Term Scheduler)

- CPU는 한 번에 하나의 process만 수행한다.
- 장기 스케줄러에 의해 메모리에 올라간 process들 중, 어떤 걸 먼저 처리할지 결정하는 것이 단기 스케줄러의 역할이다.**(메모리 - CPU 스케줄링)**
- Ready Queue의 프로세스 중 어떤 프로세스에 CPU를 할당해서 running할 지 결정한다.**(scheduler dispatch)**
- 가상 메모리 관리의 발달로 Short-Term/Long-Term 구분이 없는 요즘은, **CPU scheduler**라고도 부른다.
- 이 때, 프로세스의 상태는 **ready -> running -> waiting -> ready**가 된다.
- **호출빈도가 높다.** 특히 **오늘날** 단기 스케줄러로 거의 모든 프로세스가 제어된다.



#### 중기 스케줄러(Mid-Term Scheduler)

- CPU는 한 번의 하나의 process만 수행하는데, 사용자의 다중 작업을 지원하기 위해 메모리에 올라간 작업들 중 단기 스케줄러에 의해 먼저 처리할 작업을 선정하고, 아주 짧은 시간동안 수행하기를 반복한다.
- 즉, 단기 스케줄러가 수행할 process를 정해준다고 해도, 그 process가 끝날때까지 계속 수행하는게 아니다.
- 따라서 **CPU가 감당하기 어려울 만큼의 job이 메모리에 올라오면, 우선순위가 낮은 job은 잠시 내려뒀다가 나중에 다시 올리는 (swap) 작업을 통해 작업 효율을 높일 수 있다.**
- 이 일을 해주는 것이 중기 스케줄러이다. 역할 때문에 **swapper**라고도 부른다.
- 프로세스의 상태는 **ready -> suspended**가 된다.
- **장기 스케줄러와 마찬가지로 가상 메모리 관리가 발달하면서 사용되지 않는다.**

> `Process state - suspended`
>
> Suspended (stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태 의미한다. 프로세스 전부 디스크로 swap out 된다. blocked 상태는 다른 I/O 작업을 기다리는 상태이기 때문에 스스로 ready state로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.



