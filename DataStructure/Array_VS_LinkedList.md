## Array VS LinkedList
### 이유진
Array는 데이터의 논리적 저장 순서와 물리적 저장 순서가 일치하여 인덱스를 통해 데이터에 접근할 수 있다. LinkedList는 각각의 데이터들이 자신의 이전과 이후에 오는 데이터를 기억하고 있다.

Array는 데이터가 연속적으로 저장되어있어 인덱스를 통해 데이터에 한 번에 접근할 수 있다. 따라서 검색 속도가 빠르지만, 삽입, 삭제시 O(n)의 시간복잡도가 발생하고 크기 변경이 불가능하다.
LinkedList는 현재 데이터의 이전,다음 데이터가 무엇인지 기억한다. 따라서 삽입, 삭제를 O(1)만에 할 수 있다. 대신 검색 시 O(n)의 시간복잡도를 갖게 된다.

### 우지현

- Array

  논리적 저장순서와 물리적 저장 순서 일치

  Random Access. 인덱스만 알고 있다면 시간 복잡도 O(1)으로 해당 원소에 접근 가능

  삽입, 삭제시 해당 원소에 접근하여 작업을 완료한 뒤 shift 해주어야 하기 때문에 시간 복잡도가 O(n)

  크기가 제한적

  메모리는 Array가 선언되자마자 Compile Time에 할당됨 &#10141; 정적 메모리 할당(Static Memory Allocation)

  Stack 영역에 메모리 할당

- LinkedList

  자료의 주소값으로 서로 연결되어 있는 구조

  Tree 구조의 근간이 되는 자료구조

  Sequantial Access. 순차적으로 접근하면서 찾아야 하므로 시간 복잡도 O(n)

  처음이나 마지막에 삽입, 삭제한다면 시간 복잡도 O(1)이지만 중간에 삽입, 삭제하면 시간 복잡도 O(n)

  element를 추가할 때마다 동적으로 크기가 늘어남

  메모리는 새로운 Node가 추가될 때 Runtime에 할당됨 &#10141; 동적 메모리 할당(Dynamic Memory Allocation)

  Heap 영역에 메모리 할당

- 결론

  데이터에 접근하는 것이 중요하다면 Array

  삽입과 삭제가 빈번하다면 LinkedList

  

