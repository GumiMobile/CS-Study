## Tree 2 (BST, Segment Tree)

## 김현수

### BST(Binary Search Tree, 이진 탐색 트리)

#### BST의 정의와 특징

- 이진트리 기반의 탐색을 위한 자료구조이다.
- 이진탐색의 효율적인 탐색 능력을 가지며, 삽입과 삭제가 가능한 것이 특징이다.
- 중위순회(In-order Traversal) 방법으로 순회하며, 그 결과는 트리 내의 모든 값들을 오름차순으로 정렬한것과 같다.
- 최악의 경우 (경사이진트리 모양) 이진탐색트리의 시간복잡도는 O(n)이다.
- 최선의 경우 (포화이진트리 모양) 이진탐색트리의 시간복잡도는 O(log₂n)이다.

#### BST의 조건

- 모든 노드는 유일한 키를 갖는다. ( 키 = 노드 안에 들어 있는 데이터 값)
- 왼쪽 서브트리의 키들은 루트의 키보다 작다.
- 오른쪽 서브트리의 키들은 루트의 키보다 작다.
- 왼쪽과 오른쪽 서브트리도 이진탐색트리이다.

#### BST의 연산
- 검색(Search)
	1. 루트에서 시작한다.
	2. 검색 값을 루트와 비교한다. 루트보다 작으면 왼쪽으로, 크다면 오른쪽으로 재귀한다.
	3. 일치하는 값을 찾을 때까지 1~2를 반복한다.
	4. 검색 값이 없으면 null을 반환한다.
	
- 삽입(Insert)
	1. Root에서 시작한다.
	2. 삽입 값을 루트와 비교한다. 루트보다 작으면 왼쪽으로, 크다면 오른쪽으로 재귀한다.
	3. 리프 노드에 도달한 후 노드보다 크다면 오른쪽에, 작다면 왼쪽에 삽입한다.
	
- 삭제(Delete)
	- 삭제할 노드가 리프노드인 경우
		- 노드를 그냥 삭제한다.
	- 삭제할 노드에 자식이 하나 있는 경우
		- 노드를 삭제하고 자식 노드를 삭제된 노드의 부모에 직접 연결한다.
	- 삭제할 노드에 자식이 둘 있는 경우
		1. 삭제할 노드를 찾는다.
		2. 삭제할 노드의 successor 노드를 찾는다.
		3. 삭제할 노드와 successor 노드의 값을 바꾼다.
		4. successor 노드를 삭제한다.
		
		> successor 노드는 right subtree의 최소값, 즉 inorder 순회에서 다음 노드를 말한다.
		

<br>

### Segment Tree

#### Segment Tree의 정의와 특징
- 세그먼트 트리는 구간을 저장하기 위한 트리 이다.
- 리프노드는 배열의 값 그 자체를, 내부노드에는 자식 노드들의 합을 저장한다.
- 데이터의 합을 가장 빠르고 간단하게 구할 수 있는 자료구조
- 기존 데이터 배열의 크기를 N 이라 하면, 리프 노드의 개수가 N 이 되고, 트리의 높이 H 는 [ logN ] 이 되며, 트리의 크기는 2^(H+1) 이 된다.

>실제 노드는 2^(H+1)-1 개인데, 왜 공식에 의해서 나오는 값은 2^(H+1)개일까? 
>
>	-> 트리의 자식과 부모 관계를 계산하기 쉽게 하기 위해 배열의 0번째 인덱스를 사용하지 않고 1번 노드부터 사용하기 때문

#### 구간 합 구하기
두 구간에 대해서 왼쪽 구간을 left, 오른쪽 구간을 right 이라 할 때, 탐색 범위 [start, end] 와 합의 구간 [left, right] 의 관계는 다음과 같다.

- [left, right] 와 [start, end]가 전혀 겹치지 않는 경우
	- 탐색 범위 내에 구하는 범위가 존재하지 않는다. 그렇다면 탐색 범위에 값들은 아무 의미 없는 값이므로 0을 반환한다.
- [start, end] 가 [left, right]에 속해 있는 경우
	- 탐색 범위 내에 값들이 전부 구하는 범위의 값들이므로 하위 노드들의 합을 저장하고 있는 tree[index] 를 반환한다.
- [left, right] 와 [start, end] 가 일부 겹치는 경우
	- 위 경우에는 어디까지의 값들이 필요한지에 대해 재귀적으로 구해야 한다.
	
#### 값 변경하기
- 특정 인덱스의 값을 n만큼 증가한다고 가장하자.
- 바꾸고자 하는 Index값이 현재 탐색중인 범위 내에 속해있지 않은 경우
	- 자식 노드로 더 깊게 들어가도 해당 index가 나올 수 없으므로 탐색을 종료한다.
- 바꾸고자 하는 Index값이 현재 탐색중인 범위 내에 속해있는 경우
	- 바꾸고자 하는 Index에 대한 정보를 포함하고 있는 노드이므로 n만큼 더하고 더 깊은 탐색을 진행한다.

## 우지현

### BST (Binary Search Tree)

- 이진 트리의 일종
- 데이터를 저장하는 규칙이 있고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.
  - 규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
  - 규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
  - 규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
  - 규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.
- 이진 탐색 트리의 탐색 연산의 시간 복잡도는 O(log n)
  - 정확히 말하면 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문에 O(h)
  - 하지만 이러한 이진 탐색 트리는 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문에 Skewed Tree(편향 트리)가 될 수 있다.
  - 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case가 되고 시간 복잡도는 O(n)
- 배열보다 많은 메모리를 사용함 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황을 해결하기 위해 `Rebalancing` 기법 등장
  - `Rebalancing` : 균형을 잡기 위한 트리 구조의 재조정
  - 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중 하나가 `Red Black Tree` 

### Segment Tree

- 배열의 부분 합을 구할 때 사용하는 개념
- 구간 합을 구할 때 배열의 값이 지속적으로 바뀔 수 있기 때문에 매 순간 배열의 부분 길이 만큼, 즉 O(n)만큼의 시간이 걸린다. 이를 트리로 구현하여 O(log n)의 시간으로 해결하는 방법이다.
- 주어진 배열을 이진 트리 구조로 만들 때 배열의 요소들은 리프 노드에 위치하게 되고 부모 노드의 값은 왼쪽, 오른쪽 자식 노드 값의 합이 된다.
- 기존 배열의 크기를 n이라 하면, 리프 노드의 개수가 n이 되고 트리의 높이 h는 log n, 배열의 크기는 2^(h + 1)

#### 구간 합 구하기

왼쪽 구간을 left, 오른쪽 구간을 right라 할 때, 탐색 범위 [start, end]와 합의 구간 [left, right]의 관계는 다음과 같다.

- [left, right]와 [start, end]가 전혀 겹치지 않는 경우
  - 탐색 범위 내에 구하는 범위가 존재하지 않는다.
  - 그렇다면 탐색 범위의 값들은 아무 의미 없는 값이므로 0 반환
- [start, end]가 [left, right]에 속해 있는 경우
  - 탐색 범위 내의 값들이 전부 구하는 범위의 값들이다.
  - 하위 노드들을 탐색할 필요 없이 이미 하위 노드들의 합을 저장하고 있는 tree[index] 반환
- [left, right]가 [start, end]에 속해 있는 경우, [left, right]와 [start, end]가 일부 겹치는 경우
  - 재귀적으로 더 들어가서 어디까지의 값들이 필요한지 구한다.

#### 값 변경하기

- update 함수에 새로 바꿀 값이 아닌 새로 바꿀 값과 기존 값의 차이를 넘겨준다.
- 재귀적으로 왼쪽, 오른쪽 자식 노드를 나눠가며 start == end가 될 때까지, 즉 리프 노드가 될 때까지 탐색한다.
  - 탐색 범위 안에 없다면 종료
  - 탐색 번위 안에 있다면 변경된 노드의 차이값만큼 노드에 더해준다.


## 이수형

### BST

- BST는 이진 트리이다 
- 왼쪽 서브트리의 모든 노드는 부모의 노드보다 작다
- 오른쪽 서브트리의 모든 노드는 부모의 노드보다 큰 트리이다
- 중위순회 할 경우 정렬된 값을 얻을수 있음
- 탐색 복잡도는 O(logN)이나 자료가 편향될 수 있고 그때는 O(N)
- 편향을 해결하기 위해  AVL트리나 Red-Black트리를 사용하기도 함

### Segment Tree

배열의 부분합을 구할때 주로 쓰는 트리

- 리프노드들이 실제 배열의 값이 되며 그 부모가 합의 범위를 나타냄

### 구간합 구하기

start / end는 주어진 기존 배열의 처음과 끝이므로 1 / n을 전달한다.<br/> 
left / right는 전체 범위 내의 구간 합을 구할 구간의 시작 / 끝 지점의 값을 전달한다.

1. [left,right]와 [start,end]가 겹치지 않는 경우
  - 겹치지 않으면 해당 구간은 불필요

2. [left,right]가 [start,end]와 완전히 일치하는 경우
  - 현재 그 구간합을 보유한 노드가 정답

3. [start,end]가 [left,right]를 완전히 포함하거나 한 쪽만 겹치는 경우
  - 이 때는 left / right의 정확한 구간보다 더 넓은 범위이므로 더 아래로 내려가서 찾아야 한다.

## 이유진
### 이진탐색트리 (Binary Search Tree)
- 이진트리 기반의 탐색을 위한 자료구조
- 이진 탐색으로 효율적인 탐색 능력 (중위순회 이용)
- 삽입, 삭제 가능
- 시간복잡도 : 최선의 경우 O(logN), 최악의 경우 O(N)

#### 4가지 조건
- 모든 노드는 유일한 키를 갖는다.
- 왼쪽 서브트리의 키들은 루트의 키보다 작다.
- 오른쪽 서브트리의 키들은 루트의 키보다 작다.
- 왼쪽과 오른쪽 서브트리도 이진탐색트리이다.  


![image](https://user-images.githubusercontent.com/37680108/135008071-d6fc5b4a-3fd6-4083-b535-95875fadf936.png)

### 이진탐색트리 삭제
#### 삭제하려는 노드가 **leaf**노드인 경우
해당 노드만 삭제한다.
#### 삭제하려는 노드가 **하나의 자식**노드를 갖는 경우
해당 노드의 부모노드와 자식노드를 연결해주면 된다.
#### 삭제하려는 노드가 **두개의 자식**노드를 갖는 경우
왼쪽 서브트리에서 가장 큰 값 또는 오른쪽 서브트리에서 가장 작은 값으로 삭제되는 노드의 자리를 채운다. 그래야 이진탐색트리의 조건을 만족하며 트리의 변동성을 최소화할 수 있다.  
![image](https://user-images.githubusercontent.com/37680108/135008392-7a0f5c1d-d542-43f8-8b45-9c36869d1d24.png)



## 윤기재
### 이진탐색트리 (Binary Search Tree)
- 각 노드에 모두 값이 있다.
- 값의 중복을 허용하지 않는다.
- 각 노드의 왼쪽 하위 트리는 노드의 키보다 작은키로 구성되는 트리이다.
- 각 노드의 오른쪽 하위 트리는 노드의 키보다 큰키로 구성되는 트리이다.
- 각각의 하위트리도 모두 BST 구조이다.
- 균형 상태이면 O(logN) 의 시간
- 불균형 상태(편향)이면 최대 O(N) 의 시간

### BST 의 검색 ,삽입 , 삭제
#### 검색
1. 루트에서 시작
2. 값을 루트와 비교후 작다면 왼쪽서브트리 재귀, 크다면 오른쪽으로 재귀
3. 값을 찾을때까지 2 과정 반복
4. 검색 값이 없다면 null 반환


#### 삽입
1. 루트에서 시작
2. 값을 루트와 비교후 작다면 왼쪽 노드로 이동 , 크다면 오른쪽으로 이동
3. 리프노드에 도달까지 2과정 반복
4. 리프노드와 비교후 작다면 왼쪽으로 삽입, 아니라면 오른쪽 삽입
※ 만약 같은 값을 찾는다면 삽입하지 않는다. (중복불가)

#### 삭제
1. 삭제노드가 리프노드일 경우
- 그대로 삭제 한다.

2. 삭제노드가 자식이 하나일 경우
- 자식 노드를 부모노드에 연결후 삭제

3. 삭제노드가 자식이 두개일 경우
- successor 노드를 찾아서 위치를 변경후 삭제한다.
※ successor 노드란, 왼쪽서브 트리에서 가장 큰값 또는 오른쪽서브 트리에서 가장 작은값이다.


### 세그먼트트리(Segment Tree)
- 특정한 범위의 데이터 합을 효율적으로 구하는 자료구조
- 기존의 배열에서 연속된 범위의 합을 구하면 O(N) 으로 비효율적이다.
- 트리의 구조를 이용하여 O(logN) 시간 복잡도를 갖게된다.


### 세그먼트트리 생성
1. 첫번째 노드는 ( 첫번째 값(start) ~ 마지막 값(end) ) 의 합을 저장.
2. 두번째 노드는 ( 첫번째 값(start) ~ 중간값 값(start + end /2) ) 을 저장
3. 세번째 노드는 ( 중간값 값(start + end /2)+1 ~ 마지막값(end) ) 을 저장
4. 범위를 반씩 분할하며 1 ~3 의 과정을 반복
![생성](https://user-images.githubusercontent.com/37038119/135448107-168007b2-e132-4722-8868-e5f1fb985c75.png){: width="50%" height="50%"}


### 세그먼트트리 구간 합구하기
- 재귀적으로 범위 안에 있는 경우를 더해준다.
![구간합](https://user-images.githubusercontent.com/37038119/135448038-08021ab1-1acd-4a1f-9d7d-4177fb5a66a2.png){: width="50%" height="50%"}


### 세그먼트트리 수정
- 리프노드를 찾을때까지 범위안에 있으면 값을 수정해준다.
![수정](https://user-images.githubusercontent.com/37038119/135448115-9f23a0df-f345-4247-be57-f034bbc50cd8.png){: width="50%" height="50%"}

