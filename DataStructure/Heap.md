# Heap (Binary Heap)
## 이유진

### 힙(Heap)
완전 이진 트리의 일종으로, 여러 값 중 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조. 우선순위 큐에서 사용된다.
(중복된 값 허용)

### 종류

- 최대 힙 (Max Heap)  
부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
- 최소 힙 (Min Heap)  
부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

### 구현 by 배열
쉬운 구현을 위해 인덱스 0 은 사용하지 않는다.

#### 부모노드와 자식노드 index
> 왼쪽 자식 index = (부모 index) * 2  
> 오른쪽 자식 index = (부모 index) * 2 + 1  
> 부모 index = (자식 index) / 2  

#### 삽입
1. 새로운 요소를 힙의 마지막 노드에 삽입한다. (`heapSize+1`)
2. (maxHeap기준) 마지막 노드가 부모 노드보다 크면 swap ... (부모 노드가 더 클 때까지 반복)  

#### 삭제(최대값 찾기)
1. 루트 노드가 삭제된다. : 시간복잡도 O(1)
2. 힙의 마지막 노드를 루트 노드로 가져온다.
3. 힙을 재구성한다. <= `Heapify` : 시간복잡도 O(logN)

## 우지현

### 힙 (Heap)

자료구조의 일종으로 Tree 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree(완전 이진 트리)이다. 여러 값 중 최댓값과 최솟값을 빠르게 찾아내도록 만들어진 자료구조로 반 정렬 상태(느슨한 정렬 상태)이다. 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는  정도의 정렬 상태로 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 완전 이진 트리를 말한다. 가장 큰(작은) 값을 알아내면 되기 때문에 전체 데이터를 정렬할 필요는 없다.  힙 트리에서는 이진 탐색 트리와 달리 중복된 값을 허용한다.

### 이진 힙(Binary Heap)의 종류

![최대 힙, 최소 힙](https://img1.daumcdn.net/thumb/R1920x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlR7aO%2FbtqZSuVD2vb%2FFhBYEsoZ3hqdirkZpFDgl0%2Fimg.png)

- 최소 힙 (Min Heap)

  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

- 최대 힙 (Max Heap)

  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

### 구현

힙을 저장하는 표준적인 자료구조는 배열이다. 구현을 쉽게 하기 위해 배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 index부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다. 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.

> 💡 부모 노드와 자식 노드의 관계
>
> 왼쪽 자식 index = (부모 index) * 2
>
> 오른쪽 자식 index = (부모 index) * 2 + 1
>
> 부모 index = (자식 index) / 2

### 힙의 삽입 과정

1. 힙에 새로운 요소가 들어오면 힙의 마지막 노드에 삽입한다.
2. 새로운 노드를 부모 노드와 비교하여 자신이 더 크면 swap한다. (Max Heap 기준)

### 힙의 삭제 과정

1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.

2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.

3. 힙을 재구성한다. (heapify)

   자식 노드와 비교하여 더 큰 값과 swap한다. 이 과정을 자식 노드들이 더 작은 값을 가질 때까지 반복한다. (Max Heap 기준)

### 시간 복잡도

루트 노드는 항상 우선순위가 높은 노드이다. 이러한 원리로 최댓값 혹은 최솟값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)이다. 그리고 배열을 사용하여 heap을 관리 하기 때문에 random access가 가능하다. 하지만 노드를 삭제하는 경우 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 맨 마지막 노드를 루트 노드로 대체 시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다.  이런 경우에는 결국 O(log n)의 시간 복잡도로 최댓값 또는 최솟값에 접근할 수 있다.


### 이수형

### Heap

- 우선 순위 큐를 위하여 만들어진 자료구조로써 최대값과 최소값을 빠르게 찾아낼 수 있다.
- Max Heap과 Min Heap의 2가지가 있으며 각각은 부모의 크기가 자식보다 항상 크거나 작은 느슨한 룰로 이루어져있다
- 중복된 값을 허용한다.
- 완전 이진 트리의 일종이다
- 최댓값, 최솟값은 O(1) 만에 찾을수 있지만 삽입 삭제 경우에는 O(log N) 의 시간이 필요하다

### 삽입

1. 새로운 요소와 마지막노드와 비교한다
2. 새로운 노드를 부모노드와 비교하여 rule에 따라 swap한다( 크고 작은 느슨한 룰)

### 삭제

1. 가장 앞의 루트 노드가 삭제된다
2. 루트노드에 마지막 노드를 가져와 채운다
3. 자식과 비교하여 rule에 따라 swap한다

### 김현수
### 힙(Heap)
- 힙(Heap): 트리 기반 자료구조로 힙 속성을 만족하는 거의 완전한 트리
- 힙 속성: 최대힙(Max Heap)일 경우 부모 노드는 반드시 자식 노드보다 값이 커야하며, 따라서 최상위 노드는 최대값을 가진다. 최소 힙의 경우 반대.
	- 이러한 힙의 특성으로 힙은 우선순위 큐를 구현하는데 적합한 자료구조이다.
> 힙은 부모와 자식 노드간의 관계만이 정의되어 있을 뿐, 형제 또는 사촌 노드 간의 우선순위는 정해진 것이 없다.

### 이진 힙(Binary Heap)
- 힙 중에서 가장 널리 쓰이는 형태 중 하나로 이진 트리 형태인 힙. 
- 이진 힙은 힙정렬 알고리즘을 위한 자료구조로서 1964년 발표됨.
- 이진 힙은 완전 이진 트리라는 조건을 만족해야 한다. 
	- 완전 이진 트리는 모든 레벨의 노드가 채워져 있어야 하며, 마지막 레벨은 왼쪽부터 차 있어야 한다.
- 루트 노드는 힙의 종류에 따라 최대값 혹은 최소값을 가지므로, 최대값이나 최소값을 탐색할 때 걸리는 시간은 항상 O(1)이다.

#### 삽입(Insert)
힙에 원소를 추가하기 위해서 업힙이라는 작업을 수행한다.
1. 원소를 힙의 가장 마지막 노드에 추가.
2. 추가한 원소를 부모와 비교. 순서가 힙 조건과 일치한다면 중지.
3. 힙 조건과 순서가 맞지 않다면 부모와 위치를 교환. 힙 조건에 일치할때까지 2~3번을 반복.

#### 삭제(Delete)
힙에서 원소를 삭제하기 위해 다운힙(값을 추출하고 다음 값을 루트로 만드는 작업)을 수행한다.
1. 힙의 루트 노드를 삭제.
2. 마지막 노드를 루트로 이동. 루트를 자식 노드와 비교. 이 때, 두 자식 노드 중 최대 힙인 경우 더 큰 자식과, 최소 힙인 경우 더 작은 자식과 비교함. 순서가 힙 조건과 일치한다면 중지.
3. 만약 순서가 맞지 않는다면 위치를 교환. 힙 조건에 일치할때까지 2~3번을 반복.

## 윤상일

### 💡 힙(Heap)이란?

정식명은 Heap tree, 여러 개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 만든 이진 트리에요

- 삽입/삭제의 속도 때문에 완전 이진 트리로 나타내며, 대개 배열로 표현하는데 계산을 편하게 하기 위해 인덱스는 1부터 사용해요
- 두 종류, 최대 힙(부모 노드가 항상 자식들보다 큰 힙)과 최소 힙(부모가 항상 자식들보다 작은 힙)으로 나뉘어요
- 최댓값(최솟값)을 O(1)안에 찾을 수 있어요
- 데이터의 삽입/삭제는 O(logN)이 소요돼요
- 데이터의 삽입은 다음 프로세스로 이루어져요

>1. 가장 끝의 자리에 노드 삽입
>2. 그 노드와 부모 노드를 비교하여 규칙(최대/최소)에 맞으면 보존, 아니면 교환
>3. 규칙에 맞을 때까지 2번 과정 반복

- 데이터의 삭제는 루트 노드만 가능하며, 다음 프로세스로 이루어져요

> 1. 루트 노드(최상위 노드)를 제거
> 2. 그 자리에 가장 마지막 노드 삽입
> 3. 올라간 노트와 자식 노드들을 비교
> 4. 1. (최대 힙) 부모보다 더 큰 자식들 중 큰 값과 교환, 없으면 종료
>    2. (최소 힙) 부모보다 더 작은 자식들 중 작은 값과 교환, 없으면 종료
> 5. 4번을 반복
