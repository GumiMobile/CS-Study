# Heap (Binary Heap)
## 이유진

### 힙(Heap)
완전 이진 트리의 일종으로, 여러 값 중 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조. 우선순위 큐에서 사용된다.
(중복된 값 허용)

### 종류

- 최대 힙 (Max Heap)  
부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
- 최소 힙 (Min Heap)  
부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

### 구현 by 배열
쉬운 구현을 위해 인덱스 0 은 사용하지 않는다.

#### 부모노드와 자식노드 index
> 왼쪽 자식 index = (부모 index) * 2
> 오른쪽 자식 index = (부모 index) * 2 + 1
> 부모 index = (자식 index) / 2

#### 삽입
1. 새로운 요소를 힙의 마지막 노드에 삽입한다. (`heapSize+1`)
2. (maxHeap기준) 마지막 노드가 부모 노드보다 크면 swap ... (부모 노드가 더 클 때까지 반복)  

#### 삭제(최대값 찾기)
1. 루트 노드가 삭제된다. : 시간복잡도 O(1)
2. 힙의 마지막 노드를 루트 노드로 가져온다.
3. 힙을 재구성한다. <= `Heapify` : 시간복잡도 O(logN)

## 우지현

### 힙 (Heap)

자료구조의 일종으로 Tree 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree(완전 이진 트리)이다. 여러 값 중 최댓값과 최솟값을 빠르게 찾아내도록 만들어진 자료구조로 반 정렬 상태(느슨한 정렬 상태)이다. 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는  정도의 정렬 상태로 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 완전 이진 트리를 말한다. 가장 큰(작은) 값을 알아내면 되기 때문에 전체 데이터를 정렬할 필요는 없다.  힙 트리에서는 이진 탐색 트리와 달리 중복된 값을 허용한다.

### 이진 힙(Binary Heap)의 종류

![최대 힙, 최소 힙](https://img1.daumcdn.net/thumb/R1920x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlR7aO%2FbtqZSuVD2vb%2FFhBYEsoZ3hqdirkZpFDgl0%2Fimg.png)

- 최소 힙 (Min Heap)

  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리

- 최대 힙 (Max Heap)

  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리

### 구현

힙을 저장하는 표준적인 자료구조는 배열이다. 구현을 쉽게 하기 위해 배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 index부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다. 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.

> 💡 부모 노드와 자식 노드의 관계
>
> 왼쪽 자식 index = (부모 index) * 2
>
> 오른쪽 자식 index = (부모 index) * 2 + 1
>
> 부모 index = (자식 index) / 2

### 힙의 삽입 과정

1. 힙에 새로운 요소가 들어오면 힙의 마지막 노드에 삽입한다.
2. 새로운 노드를 부모 노드와 비교하여 자신이 더 크면 swap한다. (Max Heap 기준)

### 힙의 삭제 과정

1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.

2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.

3. 힙을 재구성한다. (heapify)

   자식 노드와 비교하여 더 큰 값과 swap한다. 이 과정을 자식 노드들이 더 작은 값을 가질 때까지 반복한다. (Max Heap 기준)

### 시간 복잡도

루트 노드는 항상 우선순위가 높은 노드이다. 이러한 원리로 최댓값 혹은 최솟값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)이다. 그리고 배열을 사용하여 heap을 관리 하기 때문에 random access가 가능하다. 하지만 노드를 삭제하는 경우 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 맨 마지막 노드를 루트 노드로 대체 시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다.  이런 경우에는 결국 O(log n)의 시간 복잡도로 최댓값 또는 최솟값에 접근할 수 있다.

