## Hash Table(Hash Function, Resolve Collision, Resize)

## 김현수

### Hash Table(해시테이블)이란

해싱이란 임의의 길이의 값을 해시함수(Hash Function)를 사용하여 고정된 크기의 값으로 변환하는 작업을 말한다. 
해시 테이블은 해싱을 사용하여 변환한 값을 색인(index)으로 삼아 키(key)와 데이터(value)를 저장한다. 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 기본 연산인 탐색(Search), 삽입(Insert), 삭제(Delete)를 기존 자료구조인 이진탐색트리나 배열에 비해서 굉장히 빠른 속도로 수행한다.

해시 테이블은 키, 해시함수, 해시, 값, 저장소(Bucket, Slot)로 이루어져 있다.
키는 해시함수를 통해 해시로 변경이 되며 해시는 값과 매칭되어 저장소에 저장이 된다.
- 키(key) : 고유한 값이며, 해시 함수의 input이 된다. 다양한 길이의 값이 될 수 있다. 이 상태로 최종 저장소에 저장이 되면 다양한 길이 만큼의 저장소를 구성해 두어야 하기 때문에 해시 함수로 값을 바꾸어 저장이 되어야 공간의 효율성을 추구할 수 있다.

- 해시함수(Hash Function) : 키를 해시로 바꿔주는 역할을 한다. 다양한 길이를 가지고 있는 키를 일정한 길이를 가지는 해시로 변경하여 저장소를 효율적으로 운영할 수 있도록 도와준다. 다만, 서로 다른 키가 같은 해시가 되는 경우를 해시 충돌(Hash Collision)이라고 하는데, 해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요하다.

- 해시 : 해시 함수의 결과물이며, 저장소에서 값과 매칭되어 저장된다.

- 값(Value) : 저장소에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 한다.


### 해시 함수
해시 테이블에 사용되는 대표적인 해시 함수는 아래와 같다.

- Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.( 주소 = 입력값 % 테이블의 크기) 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.

- Digit Folding: 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.

- Multiplication Method: 숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다. h(k)=(kAmod1) × m
  
  > kA mod 1 는 kA 의 소수점 이하 부분을 의미하며 이를 N 에 곱하므로 0부터 N 사이의 값이 된다. 이 방법의 장점은 N 이 어떤 값이더라도 잘 동작한다는 것이며 A 를 잘 설정하는 것이 중요하다.
  
- Universal Hashing: 다수의 해시함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.


### 해시 충돌

해시(hash)를 이용한 자료구조 방식에 필연적으로 나타날 수 있는 문제는,
무한한 값(해시테이블에서의 KEY)을 유한한 값(해시테이블에서의 Hash)으로 표현하면서 서로 다른 두 개 이상의 유한한 값이 동일한 출력 값을 가지게 된다는 것이다.

해시 테이블에서는 충돌에 의한 문제를 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing) 크게 2가지로 해결하고 있다.

#### 분리 연결법(Separate Chaining)

Separate Chaining이란 충돌이 발생했을 때 동일한 버킷(Bucket)의 데이터에 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 방법을 말한다. Java8의 Hash테이블은 Self-Balancing Binary Search Tree 자료구조를 사용해 Chaining 방식을 구현하였다.

이러한 Chaining 방식은 해시 테이블의 확장이 필요없고 간단하게 구현이 가능하며, 손쉽게 삭제할 수 있다는 장점이 있다. 하지만 데이터의 수가 많아지면 동일한 버킷에 chaining되는 데이터가 많아지며 그에 따라 캐시의 효율성이 감소한다는 단점이 있다.


> **리사이징(Resizing)**
>
> Separate changing에 경우, 버킷이 일정 수준으로 차 버리면 각 버킷에 연결되어 있는 List의 길이가 늘어나기 때문에, 검색 성능이 떨어지기 때문에 버킷의 개수를 늘려줘야 한다. 또한 Open addressing의 경우, 고정 크기 배열을 사용하기 때문에 데이터를 더 넣기 위해서는 배열을 확장해야 한다. 이를 리사이징(Resizing)이라고 한다.
>
> 보통 두 배로 확장하는데, 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor 라고 불린다. 리사이징은 더 큰 버킷을 가지는 array를 새로 만든 다음에, 다시 새로운 array에 hash를 다시 계산해서 복사해줘야 한다.


#### 개방 주소법(Open Addressing)
Open Addressing이란 추가적인 메모리를 사용하는 Chaining 방식과 다르게 비어있는 해시 테이블의 공간을 활용하는 방법이다. Open Addressing을 구현하기 위한 대표적인 방법으로는 3가지 방식이 존재한다.

- 선형 탐사(Linear Probing): 현재의 버킷 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
- 제곱 탐사(Quadratic Probing): 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2 칸씩 옮기는 방식이다.
- 이중 해싱(Double Hashing Probing): 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다.

Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되기 때문에 Hash Table을 재정리 해주는 작업이 필요하다.

추가적인 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하지만, 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 좌지우지되며, 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 한다는 단점이 있다.

### 해시 테이블의 성능

| 	 |평균적인 경우|	최악의 경우|
| :--: | :----: | :----:|
| 탐색 |	O(1)	| O(N) |
| 삽입 |	O(1)	| O(N) |
| 삭제 |	O(1)	| O(N) |

### 해시 테이블의 단점
- 순서가 있는 배열에는 어울리지 않는다.
	- 순서와 상관없이 key만을 가지고 hash를 찾아 저장하기 때문이다.
- 공간 효율성이 떨어진다.
	- 데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다. 공간이 부족하거나 아예 채워지지 않은 경우가 생길 가능성이 있다.
- Hash Function의 의존도가 높다.
	- 평균 데이터 처리의 시간복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않는 결과이다. 해시함수가 매우 복잡하다면 해시테이블의 성능은 떨어질것이다.


### 이수형

### Hash Table 

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조이다.
각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다.
기서 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다.<br/>
해시테이블의 삽입,삭제,탐색 연산은 O(1)을 평균적으로 가지며 최악의 경우 O(N)으로 준수한성능을 보임<br/>
그러나 해시충돌과 같은 문제가 발생할수 있고 공간복잡도가 커지며 해시함수의 의존도가 높아 해시함수성능에 따라 연산효율이 달라짐 <br/>

### 해시 충돌

키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 Direct-address table이라고 하고 해시충돌 문제가 일어나지않음
그러나 메모리 효율성이 떨어지기 때문에 사용하는 키 개수보다 해시테이블크기가 적은 해시테이블을 실제 사용함
이때 발생하는 문제가 해시충돌이며 같은 해시값에 1개이상의 값이 매칭됨

해결방안

1. 버킷에 데이터가 이미 있다면 체인처럼 노드를 추가하여 다음 노드를 가리키는 방식으로 구현(연결리스트)

2. 해시함수로 얻은 주소가 아닌, 다른 주소에 데이터를 저장할 수 있도록 허용하고 다음과같은 방법으로 충돌방지
   - 선형탐사 : 최초 해시값에 해당하는 버킷에 다른 데이터가 저장돼 있으면 해당 해시값에서 고정 폭을 옮겨 다음 해시값에 해당하는 버킷에 액세스

   - 제곱탐사 : 고정 폭으로 이동하는 선형 탐사와 달리 그 폭이 제곱수로 늘어남

   - 이중해싱 :  탐사할 해시값의 규칙성을 없애버려서 clustering을 방지함. 2개의 해시함수를 준비해서 하나는 최초의 해시값을 얻을 때, 또 다른 하나는 해시충돌이 일어났을 때 탐사 이동폭을 얻기 위해 사용

### 해시함수

- Division Method
  - 숫자로 된 키를 해시테이블 크기 m으로 나눈 나머지를 해시값으로 반환(m 은, 대개 소수(prime number)를 쓰며 특히 2의 제곱수와 거리가 먼 소수를 사용하는 것이 좋다)

- Multiplication Method
  - 숫자로 된 Key값 K와 0과 1사이의 실수 A, m을 사용하여 다음과 같은 계산을 해준다. h(k)=(kAmod1) × m (Division Method보다는 다소 느리다고 함)

- universal hasing
  - 다수의 해시함수를 만들고, 이 해시함수의 집합 H에서 무작위로 해시함수를 선택해 해시값을 만드는 기법

## 우지현

### Hash Table (해시 테이블)

![해시 테이블](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1zOw1%2FbtqL6HAW7jy%2FjpBA5pPkQFnfiZcPLakg00%2Fimg.png)

(Key, Value)의 형태로 데이터를 저장하는 자료구조 중 하나로 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 빠르게 데이터를 검색할 수 있다. 해시 테이블은 각각의 Key값에 해시함수를 적용해 배열의 고유한 index를 생성하고, 이 index를 활용해 값을 저장하거나 검색하게 된다. 여기서 실제 값이 저장되는 장소를 버킷 또는 슬롯이라고 한다. 이러한 구조로 데이터를 저장하면 Key 값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되므로 매우 빠른 데이터를 저장/삭제/조회할 수 있다. 해시 테이블의 평균 시간복잡도는 O(1)이다.

### Hash Function (해시 함수)

해시 함수에서 중요한 것은 고유한 인덱스 값을 설정하는 것이다. 해시 테이블에 사용되는 대표적인 해시 함수로는 아래의 4가지가 있다.

- Division Method
  - 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어서 계산한다. 
  - (주소 = 입력값 % 테이블의 크기)
  - 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.
- Digit Folding
  - 각 Key의 문자열을 ASCII 코드로 바꾸고 값을 합한 데이터를 테이블 내의 주소로 사용하는 방법이다.
- Multiplication Method
  - 숫자로 된 Key값 K와 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 다음과 같은 계산을 해준다.
  - h(k) = (kAmod1) x m
- Universal Hashing
  - 다수의 해시 함수를 만들어 집합 H에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법이다.

### Resolve Collision

어설픈 Hash Function을 통해서 Key값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 Key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 `Collision`이라 한다.

> Collision : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.

해시 테이블은 이러한 Collision(충돌)을 크게 2가지 방법으로 해결하고 있다.

#### Open Address 방식 (개방 주소법)

해시 충돌이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식이다. 

> 버킷 (Bucket) : 바구니와 같은 개념으로 데이터를 저장하기 위한 공간

공개 주소 방식이라고도 불리는 이 알고리즘은 Collision이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. Worst Case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 여러 방법들이 존재하는데, 다음 세 가지에 대해 알아보자.

![open address 방식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FWR1fv%2FbtqL5APCcSa%2FBZN6wvxUXzJBEiOfOMLfR0%2Fimg.png)

- Linear Probing : 현재 버킷 index로부터 고정폭만큼씩 이동하여 차례대로 검색해 비어 있는 버킷에 데이터를 저장한다.
- Quadratic Probing : 해시의 저장순서 폭을 제곱으로 저장하는 방식이다. 예를 들어 처음 충돌이 발생한 경우에는 1만큼 이동하고 그 다음 계속 충돌이 발생하면 2^2, 3^2칸씩 옮기는 방식이다.
- Double Hashing Probing : 해시된 값을 한 번 더 해싱하여 해시의 규칙성을 없애버리는 방식이다. 해시된 값을 한 번 더 해싱하여 새로운 주소를 할당하기 때문에 다른 방법들보다 많은 연산을 하게 된다. 

Open Addressing에서 데이터를 삭제하면 삭제된 공간은 Dummy Space로 활용되는데, 그렇기 때문에 해시 테이블을 재정리해주는 작업이 필요하다.

#### Separate Chaining 방식 (분리 연결법)

![Separate Chaining 방식](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbTF67c%2FbtqL7xx3OGw%2FDM8KEKU5x7dx6Nks4JR7K1%2Fimg.png)

Separate Chaining이란 동일한 버킷의 데이터에 대해 자료구조를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것이다. 일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 Worst Case에 가까워지는 빈도를 줄일 수 있다. Java 7에서는 Separate Chaining 방식을 사용하여 HashMap을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.

- Linked List(연결 리스트)를 사용하는 방식

  - 각각의 버킷들을 연결 리스트로 만들어 Collsion이 발생하면 해당 버킷의 리스트에 추가하는 방식
  - 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다.
  - 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다.
  - 버킷을 계속해서 사용하는 Open Addressing 방식에 비해 테이블의 확장을 늦출 수 있다. 

- Tree를 사용하는 방식 (Red-Black Tree)

  - 기본적인 알고리즘은 Separate Chaining 알고리즘 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식

  - 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다.

    - 트리는 기본적으로 메모리 사용량이 많기 때문에 데이터의 개수가 적다면 연결 리스트를 사용하는 것이 맞다.
    - 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 연결 리스트의 성능 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터의 개수가 적을 때는 연결 리스트를 사용한다.

    > 데이터가 적다는 것은 얼마나 적다는 것일까?
    >
    > key-value 쌍의 개수가 6개, 8개일 때를 기준으로 결정한다. 이는 각각 자료구조로 넘어가는 Switching 비용을 줄이기 위함이다. 각 자료구조로 변경되는 기준이 1이라면 1개 증가, 감소할 때마다 자료구조를 변경해야 해서 비용이 너무 많이 필요하게 될 것이다. 그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6개에서 7개로 증가했을 때는 연결 리스트의 자료구조를 취하고 있을 것이고 8개에서 7개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.

### 해시 버킷 동적 확장 (Resize)

해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 그래서 HashMap은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다. 여기서 '**일정 개수 이상**'이란 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. `0.75`라는 숫자는 load factor라고 불린다.

### Java의 HashMap과 HashTable의 차이

Java의 HashMap과 HashTable의 차이는 동기화 지원 여부이다. HashMap과 HashTable의 put 메서드를 비교해보았을 때 HashTable의 put 메서드 앞에는 synchronized 키워드가 붙어있는 것을 확인할 수 있다. 이는 병렬 프로그래밍을 할 때 동기화를 지원해준다는 의미로 해당 함수를 처리하는 시간이 조금 지연됨을 의미한다. 그렇기 때문에 병렬 처리를 하면서 자원의 동개화를 고려해야 하는 상황이라면 HashTable을, 벙렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 HashMap을 사용하면 된다.

